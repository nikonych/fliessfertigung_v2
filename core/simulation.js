// core/simulation.js
import {draw, startAnimation, stopAnimation} from "../ui/simulation/renderer.js";

function calculateDayFromDate(dateString) {
    const targetDate = new Date(dateString);
    const baseDate = new Date('2022-01-01');
    const diffTime = targetDate.getTime() - baseDate.getTime();
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
}


window.simulation = {
    simulationMinutesPerStep: 1,
    isRunning: false,
    currentTimeMinutes: calculateDayFromDate('2022-01-01') * 24 * 60,
    intervalMs: 1000,
    timer: null,
    auftraegeQueue: [],
    activeTasks: [],
    maschinenStatus: {},
    auftraege: [],
    maschinen: [],
    arbeitsplaene: [],
    recentActivities: [],
    startTime: null,
    auftraegeStatus: {},
    statistics: {
        completedTasks: 0,
        totalProcessingTime: 0,
        machineUtilization: {},
        // –ù–û–í–´–ï –ø–æ–ª—è –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        orderStatistics: {}, // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–∞–∂–¥–æ–º—É –∑–∞–∫–∞–∑—É
        machineIdleTime: {}, // –í—Ä–µ–º—è –ø—Ä–æ—Å—Ç–æ—è –∫–∞–∂–¥–æ–π –º–∞—à–∏–Ω—ã
        bufferStatistics: {}, // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±—É—Ñ–µ—Ä–Ω—ã—Ö —Å–∫–ª–∞–¥–æ–≤
        totalSimulationTime: 0,
        systemStartTime: null
    }
};

function setSimulationStartDate(dateString) {
    const dayNumber = calculateDayFromDate(dateString);
    window.simulation.currentTimeMinutes = dayNumber * 24 * 60;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
async function loadInitialData() {
    try {

        // –ï—Å–ª–∏ —ç—Ç–æ Electron –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º IPC –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
        if (window.electronAPI) {
            window.simulation.auftraege = await window.electronAPI.getAuftraege();
            window.simulation.maschinen = await window.electronAPI.getMaschinen();
            window.simulation.arbeitsplaene = await window.electronAPI.getArbeitsplaene();
        } else {
            // –î–ª—è –≤–µ–±-–≤–µ—Ä—Å–∏–∏ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å fetch API
            try {
                const [auftraegeRes, maschinenRes, arbeitsplaeneRes] = await Promise.all([
                    fetch('/api/auftraege'),
                    fetch('/api/maschinen'),
                    fetch('/api/arbeitsplaene')
                ]);

                window.simulation.auftraege = await auftraegeRes.json();
                window.simulation.maschinen = await maschinenRes.json();
                window.simulation.arbeitsplaene = await arbeitsplaeneRes.json();
            } catch (fetchError) {
                loadTestData();
                return;
            }
        }
        console.log("üìã √úberpr√ºfung der geladenen Daten:");
        console.log(`- Auftr√§ge: ${window.simulation.auftraege.length}`);
        console.log(`- Maschinen: ${window.simulation.maschinen.length}`);
        console.log(`- Arbeitspl√§ne: ${window.simulation.arbeitsplaene.length}`);



        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—à–∏–Ω
        initMaschinen(window.simulation.maschinen);

        // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∑–∞–∫–∞–∑–æ–≤ –ø–æ —Ç–µ–∫—É—â–µ–º—É –¥–Ω—é (–∑–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–∫–∞–∑—ã)
        filterAndLoadActiveAuftraege();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–∞–∫–∞–∑–æ–≤
        initAuftraegeStatus();

        addActivity(`Es wurden ${window.simulation.auftraege.length} Auftr√§ge und ${window.simulation.maschinen.length} Maschinen geladen`);

   } catch (error) {
    console.error("‚ùå Fehler beim Laden der Daten:", error);
    addActivity("Fehler beim Laden der Daten, Testdaten werden verwendet");
    loadTestData();
}
}

function addActivity(message) {
    const timestamp = new Date().toLocaleTimeString();
    window.simulation.recentActivities.push(`[${timestamp}] ${message}`);

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–±—ã—Ç–∏–π
    if (window.simulation.recentActivities.length > 10) {
        window.simulation.recentActivities = window.simulation.recentActivities.slice(-10);
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∏ –∑–∞–≥—Ä—É–∑–∫–∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤
function filterAndLoadActiveAuftraege() {
    console.log("üîç Filterung der aktiven Auftr√§ge...");

    const currentDay = getCurrentDay();
    console.log(`üìÖ Aktueller Simulations-Tag: ${currentDay}`);

    const allOrders = window.simulation.auftraege || [];
    console.log(`üì¶ Gesamtanzahl der zu pr√ºfenden Auftr√§ge: ${allOrders.length}`);

    // KORREKTUR: Erweiterung des Ladefensters f√ºr Auftr√§ge
    window.simulation.auftraegeQueue = allOrders.filter(auftrag => {
        if (!auftrag.auftrag_nr) {
            console.warn(`‚ö†Ô∏è Auftrag ohne Nummer:`, auftrag);
            return false;
        }

        let startDay;
        if (typeof auftrag.Start === 'number') {
            startDay = auftrag.Start;
        } else if (typeof auftrag.Start === 'string') {
            startDay = calculateDayFromDate(auftrag.Start);
        } else {
            console.warn(`‚ö†Ô∏è Ung√ºltiges Startdatum f√ºr Auftrag ${auftrag.auftrag_nr}:`, auftrag.Start);
            return false;
        }

        const hasWorkPlan = window.simulation.arbeitsplaene.some(
            plan => plan.auftrag_nr === auftrag.auftrag_nr
        );

        if (!hasWorkPlan) {
            console.warn(`‚ö†Ô∏è Kein Arbeitsplan f√ºr Auftrag ${auftrag.auftrag_nr}`);
            return false;
        }

        // KORREKTUR: Alle Auftr√§ge laden, nicht nur die mit Start in den n√§chsten 7 Tagen
        // Auftr√§ge werden verarbeitet, sobald ihre Zeit gekommen ist
        const shouldBeLoaded = true; // Alle Auftr√§ge werden geladen

        console.log(`  üìã Auftrag ${auftrag.auftrag_nr}: Start=${startDay}, geladen=${shouldBeLoaded}`);

        return shouldBeLoaded;
    });

    console.log(`‚úÖ Geladene Auftr√§ge: ${window.simulation.auftraegeQueue.length}`);
}


// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–∞–∫–∞–∑–æ–≤
function initAuftraegeStatus() {
    console.log("üîÑ Initialisierung der Auftragsstatus...");

    window.simulation.auftraegeStatus = {};

    if (!window.simulation.auftraegeQueue || window.simulation.auftraegeQueue.length === 0) {
        console.warn("‚ö†Ô∏è Keine Auftr√§ge in der Warteschlange zur Initialisierung!");
        return;
    }

    for (const auftrag of window.simulation.auftraegeQueue) {
        // Hole die Arbeitspl√§ne f√ºr den Auftrag
        const arbeitsplaene = getArbeitsplaeneFor(auftrag.auftrag_nr)
            .sort((a, b) => (a.reihenfolge || 0) - (b.reihenfolge || 0));

        if (arbeitsplaene.length === 0) {
            console.warn(`‚ö†Ô∏è Keine Arbeitspl√§ne f√ºr Auftrag ${auftrag.auftrag_nr}`);
            continue;
        }

        const currentTime = window.simulation.currentTimeMinutes;

        // Erstelle den Auftragsstatus
        window.simulation.auftraegeStatus[auftrag.auftrag_nr] = {
            currentStep: 0,
            arbeitsplaene: arbeitsplaene,
            completed: false,
            waiting: false,
            anzahl: auftrag.Anzahl || 1,
            enteredSystemTime: currentTime,
            waitingStartTime: currentTime, // Wartezeit beginnt sofort
            totalWaitingTime: 0,
            currentOperationStartTime: null,
            operationHistory: [],
            bufferEntryTime: null,
        };

        // Initialisiere Statistik f√ºr den Auftrag
        window.simulation.statistics.orderStatistics[auftrag.auftrag_nr] = {
            startTime: null,
            endTime: null,
            totalLeadTime: 0,
            operations: [],
            totalProcessingTime: 0,
            totalWaitingTime: 0,
            quantity: auftrag.Anzahl || 1,
            machinesUsed: [],
            operationHistory: [],
            enteredSystemTime: currentTime
        };

        console.log(`‚úÖ Auftrag ${auftrag.auftrag_nr} mit ${arbeitsplaene.length} Operationen initialisiert`);
    }

    console.log(`‚úÖ Insgesamt ${Object.keys(window.simulation.auftraegeStatus).length} Auftr√§ge initialisiert`);
}


// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–±–æ—á–∏—Ö –ø–ª–∞–Ω–æ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–∞–∫–∞–∑–∞
function getArbeitsplaeneFor(auftrag_nr) {
    return window.simulation.arbeitsplaene.filter(plan => plan.auftrag_nr === auftrag_nr);
}

function calculateOperationDuration(auftrag, arbeitsplan) {
    const anzahl = auftrag.Anzahl || 1; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–∞
    const dauerPerUnit = arbeitsplan.dauer || 0; // –í—Ä–µ–º—è –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É —Ç–æ–≤–∞—Ä–∞ –≤ –º–∏–Ω—É—Ç–∞—Ö
    const totalDauer = anzahl * dauerPerUnit; // –û–±—â–µ–µ –≤—Ä–µ–º—è –æ–ø–µ—Ä–∞—Ü–∏–∏

    console.log(`üìä Zeitberechnung f√ºr Auftrag ${auftrag.auftrag_nr}: ${anzahl} Stk √ó ${dauerPerUnit} Min = ${totalDauer} Min`);

    return totalDauer;
}

// –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–ª—É—á–∞–π –ø—Ä–æ–±–ª–µ–º —Å –ë–î
function loadTestData() {

   window.simulation.maschinen = [
        {Nr: 1, Bezeichnung: "Maschine A", Kap_Tag: 8, verf_von: "2022-01-01", verf_bis: "2023-12-31"},
        {Nr: 2, Bezeichnung: "Maschine B", Kap_Tag: 6, verf_von: "2022-01-01", verf_bis: "2023-12-31"},
        {Nr: 3, Bezeichnung: "Maschine C", Kap_Tag: 10, verf_von: "2022-01-01", verf_bis: "2023-12-31"}
    ];


    window.simulation.auftraege = [
        {auftrag_nr: "A001", Anzahl: 100, Start: 45000},
        {auftrag_nr: "A002", Anzahl: 50, Start: 45001},
        {auftrag_nr: "A003", Anzahl: 75, Start: 45002}
    ];

    window.simulation.arbeitsplaene = [
        {auftrag_nr: "A001", maschine: 1, dauer: 16, reihenfolge: 1},
        {auftrag_nr: "A001", maschine: 2, dauer: 12, reihenfolge: 2},
        {auftrag_nr: "A002", maschine: 2, dauer: 10, reihenfolge: 1},
        {auftrag_nr: "A002", maschine: 3, dauer: 8, reihenfolge: 2},
        {auftrag_nr: "A003", maschine: 1, dauer: 20, reihenfolge: 1}
    ];

    initMaschinen(window.simulation.maschinen);
    filterAndLoadActiveAuftraege();
    initAuftraegeStatus();
    addActivity("Testdaten wurden geladen");
}

function startSimulation() {
    if (window.simulation.isRunning) return;

    window.simulation.isRunning = true;
    window.simulation.startTime = Date.now();
    if (!window.simulation.statistics.systemStartTime) {
        window.simulation.statistics.systemStartTime = window.simulation.currentTimeMinutes;
    }
    window.simulation.timer = setInterval(simulationStep, window.simulation.intervalMs);

    addActivity("Simulation gestartet");
    startAnimation();
}

function stopSimulation() {
    console.log("‚è∏Ô∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏");
    window.simulation.isRunning = false;
    clearInterval(window.simulation.timer);

    addActivity("Simulation gestoppt");
    stopAnimation();
    draw(); // –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
}

async function resetSimulation() {
    console.log("üîÑ Simulation zur√ºcksetzen");
    stopSimulation();

    // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏–º—É–ª—è—Ü–∏–∏
    window.simulation.currentTimeMinutes = calculateDayFromDate('2022-01-01') * 24 * 60;

    window.simulation.activeTasks = [];
    window.simulation.auftraegeQueue = [];
    window.simulation.maschinenStatus = {};
    window.simulation.auftraegeStatus = {};
    window.simulation.recentActivities = [];
    window.simulation.startTime = null;
    window.simulation.statistics = {
        completedTasks: 0,
        totalProcessingTime: 0,
        machineUtilization: {},
        orderStatistics: {},
        machineIdleTime: {},
        bufferStatistics: {}, // –î–û–ë–ê–í–ò–¢–¨
        totalSimulationTime: 0,
        systemStartTime: null
    };

    // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    await loadInitialData();
    console.log("üîÑ Simulation zur√ºcksetzen");
    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    draw();
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å–∏–º—É–ª—è—Ü–∏–∏
function getCurrentSimulationSpeed() {
    return window.simulation.simulationMinutesPerStep || 1;
}

function getCurrentDay() {
    return Math.floor(window.simulation.currentTimeMinutes / (24 * 60));
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–Ω—è —Å–∏–º—É–ª—è—Ü–∏–∏ –≤ –¥–∞—Ç—É
function getCurrentDate() {
    const dayNumber = getCurrentDay();
    // –ë–∞–∑–æ–≤–∞—è –¥–∞—Ç–∞ - 1 —è–Ω–≤–∞—Ä—è 2020 –≥–æ–¥–∞ (–¥–µ–Ω—å 0)
    const baseDate = new Date('2022-01-01');
    const currentDate = new Date(baseDate);
    currentDate.setDate(baseDate.getDate() + dayNumber);
    return currentDate;
}


// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –º–∞—à–∏–Ω—ã
function isMachineAvailable(machine) {
    const currentDate = getCurrentDate();

    let verfVon, verfBis;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤ –∫–∞–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–∞–Ω–Ω—ã–µ
    if (typeof machine.verf_von === 'number' && typeof machine.verf_bis === 'number') {
        verfVon = excelToDate(machine.verf_von);
        verfBis = excelToDate(machine.verf_bis);

    } else {
        // –ï—Å–ª–∏ —ç—Ç–æ —Å—Ç—Ä–æ–∫–∏
        verfVon = new Date(machine.verf_von);
        verfBis = new Date(machine.verf_bis);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ª–∏ —Ä–∞—Å–ø–∞—Ä—Å–∏–ª–∏—Å—å –¥–∞—Ç—ã
        if (isNaN(verfVon.getTime()) || isNaN(verfBis.getTime())) {
        console.error(`‚ùå Ung√ºltiges Datumsformat:`, machine.verf_von, machine.verf_bis);
            return false;
        }
    }

    // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–∞—Ç—ã (–±–µ–∑ –≤—Ä–µ–º–µ–Ω–∏)
    const currentDateOnly = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
    const verfVonOnly = new Date(verfVon.getFullYear(), verfVon.getMonth(), verfVon.getDate());
    const verfBisOnly = new Date(verfBis.getFullYear(), verfBis.getMonth(), verfBis.getDate());

    const isAvailable = currentDateOnly >= verfVonOnly && currentDateOnly <= verfBisOnly;

    return isAvailable;
}

function excelToDate(serial) {
    // Excel —Å—á–∏—Ç–∞–µ—Ç –¥–Ω–∏ —Å 1 —è–Ω–≤–∞—Ä—è 1900, –Ω–æ –∏–º–µ–µ—Ç –æ—à–∏–±–∫—É —Å –≤–∏—Å–æ–∫–æ—Å–Ω—ã–º –≥–æ–¥–æ–º
    // –ü–æ—ç—Ç–æ–º—É –∏—Å–ø–æ–ª—å–∑—É–µ–º 30 –¥–µ–∫–∞–±—Ä—è 1899 –∫–∞–∫ –±–∞–∑–æ–≤—É—é –¥–∞—Ç—É
    const excelEpoch = new Date(1899, 11, 30); // 30 –¥–µ–∫–∞–±—Ä—è 1899
    const date = new Date(excelEpoch.getTime() + serial * 86400 * 1000);
    return date; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º Date –æ–±—ä–µ–∫—Ç, –∞ –Ω–µ —Å—Ç—Ä–æ–∫—É
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –≤ –¥–Ω–µ (–≤ –º–∏–Ω—É—Ç–∞—Ö –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–Ω—è)
function getCurrentTimeInDay() {
    return window.simulation.currentTimeMinutes % (24 * 60);
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —Ä–∞–±–æ—Ç–∞–µ—Ç –ª–∏ –º–∞—à–∏–Ω–∞ –≤ –¥–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
function isMachineWorkingTime(machine) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –º–∞—à–∏–Ω—ã –ø–æ –¥–∞—Ç–∞–º
    if (!isMachineAvailable(machine)) return false;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≤—ã—Ö–æ–¥–Ω–æ–π –ª–∏ –¥–µ–Ω—å (—Å—É–±–±–æ—Ç–∞ = 6, –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ = 0)
    const currentDate = getCurrentDate();
    const dayOfWeek = currentDate.getDay();
    if (dayOfWeek === 0 || dayOfWeek === 6) {
        return false; // –í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –∏–ª–∏ —Å—É–±–±–æ—Ç–∞ - –≤—ã—Ö–æ–¥–Ω–æ–π
    }

    const timeInDay = getCurrentTimeInDay();
    const workingHours = machine.Kap_Tag * 60; // –ü–µ—Ä–µ–≤–æ–¥–∏–º —á–∞—Å—ã –≤ –º–∏–Ω—É—Ç—ã

    // –†–∞–±–æ—á–∏–π –¥–µ–Ω—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤ 08:00 (480 –º–∏–Ω—É—Ç –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–Ω—è)
    const workStart = 8 * 60; // 08:00
    const workEnd = workStart + workingHours;

    const isWorkingTime = timeInDay >= workStart && timeInDay < workEnd;

    return isWorkingTime;
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —Ä–∞–±–æ—Ç–∞–µ—Ç –ª–∏ –º–∞—à–∏–Ω–∞ –≤ –¥–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è —Å —É—á–µ—Ç–æ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
function isMachineWorkingTimeAndAvailable(machine) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤—Å–µ —É—Å–ª–æ–≤–∏—è
    return isMachineWorkingTime(machine);
}

// –û—Å–Ω–æ–≤–Ω—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–∏–º—É–ª—è—Ü–∏–∏

// 1. –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è checkSimulationCompletion
function checkSimulationCompletion() {
    if (!window.simulation.isRunning) {
        return false;
    }

    const currentDay = getCurrentDay();
    const hasActiveTasks = window.simulation.activeTasks.length > 0;

    console.log(`üîç √úberpr√ºfung des Simulationsendes (Tag ${currentDay}):`);
    console.log(`  - Aktive Aufgaben: ${window.simulation.activeTasks.length}`);


    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∑–∞–∫–∞–∑—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –¥–æ–ª–∂–Ω—ã –±—ã–ª–∏ –Ω–∞—á–∞—Ç—å—Å—è
    const readyOrders = window.simulation.auftraegeQueue.filter(auftrag => {
        let startDay;
        if (typeof auftrag.Start === 'number') {
            startDay = auftrag.Start;
        } else if (typeof auftrag.Start === 'string') {
            startDay = calculateDayFromDate(auftrag.Start);
        } else {
            return false;
        }
        return startDay <= currentDay;
    });

    // –ü–æ–ª—É—á–∞–µ–º –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã –∏–∑ —Ç–µ—Ö, —á—Ç–æ —É–∂–µ –¥–æ–ª–∂–Ω—ã –±—ã–ª–∏ –Ω–∞—á–∞—Ç—å—Å—è
    const incompleteReadyOrders = readyOrders.filter(auftrag => {
        const status = window.simulation.auftraegeStatus[auftrag.auftrag_nr];
        return status && !status.completed;
    });

    console.log(`  - Auftr√§ge bereit zur Verarbeitung: ${readyOrders.length}`);
    console.log(`  - Nicht abgeschlossene, aber bereite Auftr√§ge: ${incompleteReadyOrders.length}`);


    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—á–µ—Ä–µ–¥–∏ –º–∞—à–∏–Ω –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –≥–æ—Ç–æ–≤—ã—Ö –∑–∞–∫–∞–∑–æ–≤
    let totalQueuedReadyOrders = 0;
    Object.values(window.simulation.maschinenStatus).forEach(machineStatus => {
        const queuedReadyOrders = machineStatus.queue.filter(queueItem => {
            const auftrag = window.simulation.auftraegeQueue.find(a => a.auftrag_nr === queueItem.auftrag_nr);
            if (!auftrag) return false;

            let startDay;
            if (typeof auftrag.Start === 'number') {
                startDay = auftrag.Start;
            } else if (typeof auftrag.Start === 'string') {
                startDay = calculateDayFromDate(auftrag.Start);
            }
            return startDay <= currentDay;
        });
        totalQueuedReadyOrders += queuedReadyOrders.length;
    });

    console.log(`  - Bereite Auftr√§ge in den Maschinenwarteschlangen: ${totalQueuedReadyOrders}`);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞–∫–∞–∑—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∏—Å—å
    const futureOrders = window.simulation.auftraegeQueue.filter(auftrag => {
        let startDay;
        if (typeof auftrag.Start === 'number') {
            startDay = auftrag.Start;
        } else if (typeof auftrag.Start === 'string') {
            startDay = calculateDayFromDate(auftrag.Start);
        }
        return startDay > currentDay;
    });

    console.log(`  - Auftr√§ge in der Zukunft: ${futureOrders.length}`);

    // –£–°–õ–û–í–ò–ï –ó–ê–í–ï–†–®–ï–ù–ò–Ø: –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á, –Ω–µ—Ç –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –≥–æ—Ç–æ–≤—ã—Ö –∑–∞–∫–∞–∑–æ–≤, –Ω–µ—Ç –≥–æ—Ç–æ–≤—ã—Ö –∑–∞–∫–∞–∑–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—è—Ö
    const shouldComplete = !hasActiveTasks &&
        incompleteReadyOrders.length === 0 &&
        totalQueuedReadyOrders === 0;

    if (shouldComplete) {
        if (futureOrders.length > 0) {
            // –ï—Å—Ç—å –∑–∞–∫–∞–∑—ã –≤ –±—É–¥—É—â–µ–º - –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –∑–∞–∫–∞–∑—É
            const nextOrderStartDays = futureOrders.map(auftrag => {
                if (typeof auftrag.Start === 'number') {
                    return auftrag.Start;
                } else if (typeof auftrag.Start === 'string') {
                    return calculateDayFromDate(auftrag.Start);
                }
                return Infinity;
            }).filter(day => day !== Infinity);

            if (nextOrderStartDays.length > 0) {
                const nextOrderDay = Math.min(...nextOrderStartDays);
                const minutesToJump = (nextOrderDay - currentDay) * 24 * 60;

            console.log(`‚è≠Ô∏è √úberspringe zu Tag ${nextOrderDay} (${minutesToJump} Minuten)`);
            window.simulation.currentTimeMinutes += minutesToJump;
            addActivity(`Wechsel zu Tag ${nextOrderDay}`);
            return false;
             // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å–∏–º—É–ª—è—Ü–∏—é
            }
        }

        // –í—Å–µ –∑–∞–∫–∞–∑—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã - –ù–ï–ú–ï–î–õ–ï–ù–ù–û –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º
        const completedOrdersCount = Object.values(window.simulation.auftraegeStatus)
            .filter(status => status.completed).length;

        console.log("üéâ ALLE AUFTR√ÑGE ABGESCHLOSSEN! SIMULATION WIRD SOFORT GESTOPPT!");
        addActivity(`üéâ SIMULATION BEENDET! Verarbeitete Auftr√§ge: ${completedOrdersCount}`);


        stopSimulation();
        return true; // –ó–∞–≤–µ—Ä—à–∞–µ–º —Å–∏–º—É–ª—è—Ü–∏—é
    }

    return false;
}

// 2. –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è simulationStep —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π
function simulationStep() {
    console.log("üîÑ === START DES SIMULATIONSSCHRITTS ===");
    console.log(`‚è∞ Aktuelle Zeit: ${window.simulation.currentTimeMinutes} Min (Tag ${getCurrentDay()})`);

    const totalSpeed = getCurrentSimulationSpeed();
    const maxStepSize = 60;
    let remainingTime = totalSpeed;

    while (remainingTime > 0) {
        const currentStepSize = Math.min(remainingTime, maxStepSize);
        window.simulation.statistics.totalSimulationTime += currentStepSize;
        window.simulation.currentTimeMinutes += currentStepSize;
        remainingTime -= currentStepSize;

        // Aktualisiere Maschinenstatus
        updateMachineStatuses();

        // F√ºge bereite Auftr√§ge in Maschinenwarteschlangen ein
        processReadyOrders();

        // Starte neue Aufgaben von Maschinen
        startNewTasks();

        // Verarbeite aktive Aufgaben
        processActiveTasks();

        // Bereinige abgeschlossene Auftr√§ge
        cleanupCompletedOrders();

        updateMachineUtilization();

        // *** F√úGE √úBERPR√úFUNG AUF SIMULATIONSENDE INNERHALB DER SCHLEIFE HINZU ***
        // √úberpr√ºfe das Ende der Simulation nach jedem Mini-Schritt
        const completed = checkSimulationCompletion();
        if (completed) {
            console.log("‚úÖ Simulation innerhalb des Schritts beendet, breche Verarbeitung ab");
            return; // Sofortiger Abbruch der Funktion
        }
    }

    // Wenn kein Abbruch ‚Äì aktualisiere Darstellung
    draw();

    console.log("=== ENDE DES SIMULATIONSSCHRITTS ===\n");
}


// 3. –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ª—É—á—à–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫–æ–¥–∞
function updateMachineStatuses() {
    Object.keys(window.simulation.maschinenStatus).forEach(machineId => {
        const machineStatus = window.simulation.maschinenStatus[machineId];
        const machineData = window.simulation.maschinen.find(m => m.Nr == machineId);

        if (machineData) {
            const isAvailable = isMachineAvailable(machineData);
            const isWorkingTime = isMachineWorkingTimeAndAvailable(machineData);
            const activeTask = window.simulation.activeTasks.find(task => task.maschine == machineId);
            const hasActiveTask = Boolean(activeTask);

            machineStatus.verfuegbar = isAvailable;
            machineStatus.hasUnfinishedTask = hasActiveTask;

            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ö–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –º–∞—à–∏–Ω—ã
            if (hasActiveTask && !isWorkingTime) {
                // –ï—Å—Ç—å –∑–∞–¥–∞—á–∞, –Ω–æ –Ω–µ —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è - –º–∞—à–∏–Ω–∞ –∂–¥–µ—Ç
                machineStatus.waitingForWorkingTime = true;
                machineStatus.frei = false; // –ú–∞—à–∏–Ω–∞ –∑–∞–Ω—è—Ç–∞ (—Ö–æ—Ç—è –∏ –Ω–∞ –ø–∞—É–∑–µ)
                machineStatus.canStartNewTask = false;
            } else if (hasActiveTask && isWorkingTime) {
                // –ï—Å—Ç—å –∑–∞–¥–∞—á–∞ –∏ —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è - –º–∞—à–∏–Ω–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç
                machineStatus.waitingForWorkingTime = false;
                machineStatus.frei = false;
                machineStatus.canStartNewTask = false;
            } else if (!hasActiveTask && isWorkingTime && isAvailable) {
                // –ù–µ—Ç –∑–∞–¥–∞—á, —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è, –¥–æ—Å—Ç—É–ø–Ω–∞ - –º–æ–∂–µ—Ç –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
                machineStatus.waitingForWorkingTime = false;
                machineStatus.frei = true;
                machineStatus.canStartNewTask = true;
            } else {
                // –í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å–ª—É—á–∞–∏ - –Ω–µ –º–æ–∂–µ—Ç –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
                machineStatus.waitingForWorkingTime = false;
                machineStatus.frei = true;
                machineStatus.canStartNewTask = false;
            }
        }
    });
}

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è processActiveTasks —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Å–±–æ—Ä–æ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
function processActiveTasks() {
    window.simulation.activeTasks = window.simulation.activeTasks.filter(task => {
        const machineData = window.simulation.maschinen.find(m => m.Nr == task.maschine);

        if (!machineData) {
            console.error(`‚ùå Maschine ${task.maschine} ist nicht gefunden!`);
            return false;
        }

        const canWork = isMachineWorkingTimeAndAvailable(machineData);

        if (!canWork) {
            if (!task.paused) {
                task.paused = true;
                task.pauseStartTime = window.simulation.currentTimeMinutes;
                console.log(`‚è∏Ô∏è Auftrag ${task.auftrag_nr} auf Maschine ${task.maschine} wurde pausiert`);
            }
            return true;
        } else {
            if (task.paused) {
                task.paused = false;
                const pauseDuration = window.simulation.currentTimeMinutes - (task.pauseStartTime || 0);
                task.pausedTotalTime = (task.pausedTotalTime || 0) + pauseDuration;
                console.log(`‚ñ∂Ô∏è Auftrag ${task.auftrag_nr} wurde fortgesetzt (Pause: ${pauseDuration} Min)`);
            }
        }

        if (task.paused) {
            return true;
        }

        const currentStepSize = Math.min(window.simulation.simulationMinutesPerStep, 60);
        task.remaining -= currentStepSize;
        task.processedUnits = Math.floor((1 - task.remaining / task.totalDuration) * task.anzahl);

        if (task.remaining <= 0) {
            console.log(`‚úÖ Aufgabe abgeschlossen: Auftrag ${task.auftrag_nr} auf Maschine ${task.maschine}`);
            console.log(`‚úÖ Aufgabe abgeschlossen: Auftrag ${task.auftrag_nr} auf Maschine ${task.maschine}`);

            // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –º–∞—à–∏–Ω—É
            const maschine = window.simulation.maschinenStatus[task.maschine];
            maschine.frei = true;
            maschine.hasUnfinishedTask = false;

            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–∞—à–∏–Ω—ã
            const utilization = window.simulation.statistics.machineUtilization[task.maschine];
            if (utilization) {
                utilization.operationsCompleted++;
                utilization.totalPartsProcessed += task.anzahl;
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
            const auftragStatus = window.simulation.auftraegeStatus[task.auftrag_nr];
            const orderStats = window.simulation.statistics.orderStatistics[task.auftrag_nr];

            if (auftragStatus && orderStats) {
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏—é –≤ –∏—Å—Ç–æ—Ä–∏—é
                const operationRecord = {
                    operationNumber: auftragStatus.currentStep + 1,
                    machineId: task.maschine,
                    startTime: task.startTime,
                    endTime: window.simulation.currentTimeMinutes,
                    duration: task.totalDuration,
                    actualDuration: task.totalDuration + (task.pausedTotalTime || 0),
                    unitsProcessed: task.anzahl,
                    waitingTimeBefore: task.waitingTimeBefore || 0,
                    pausedTime: task.pausedTotalTime || 0
                };

                orderStats.operations.push(operationRecord);
                auftragStatus.operationHistory.push(operationRecord);

                auftragStatus.currentStep++;

                if (auftragStatus.currentStep >= auftragStatus.arbeitsplaene.length) {
                    // –ó–∞–∫–∞–∑ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≤–µ—Ä—à–µ–Ω
                    auftragStatus.completed = true;

                    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–∫–∞–∑–∞
                    orderStats.endTime = window.simulation.currentTimeMinutes;
                    orderStats.totalLeadTime = orderStats.endTime - orderStats.enteredSystemTime;
                    orderStats.totalProcessingTime = orderStats.operations.reduce(
                        (sum, op) => sum + op.duration, 0
                    );
                    orderStats.totalWaitingTime = orderStats.operations.reduce(
                        (sum, op) => sum + op.waitingTimeBefore, 0
                    );

                    window.simulation.statistics.completedTasks++;
                    console.log(`üéâ Auftrag ${task.auftrag_nr} vollst√§ndig abgeschlossen!`);
                    addActivity(`Auftrag ${task.auftrag_nr} vollst√§ndig abgeschlossen`);

                } else {
                    // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –æ–ø–µ—Ä–∞—Ü–∏–∏
                    auftragStatus.waitingStartTime = window.simulation.currentTimeMinutes;
                    console.log(`‚û°Ô∏è –ó–∞–∫–∞–∑ ${task.auftrag_nr} –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ –æ–ø–µ—Ä–∞—Ü–∏–∏ ${auftragStatus.currentStep + 1}`);
                }
            }

            return false; // –£–¥–∞–ª—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—É—é –∑–∞–¥–∞—á—É
        }
        return true;
    });
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ –±—É—Ñ–µ—Ä–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
function updateBufferStatistics(machineId, auftrag_nr, action, additionalData = {}) {
    const bufferStats = window.simulation.statistics.bufferStatistics[machineId];
    if (!bufferStats) return;

    const entry = {
        time: window.simulation.currentTimeMinutes,
        auftrag_nr: auftrag_nr,
        action: action, // 'enter_queue', 'start_processing', 'complete_processing'
        currentQueueLength: window.simulation.maschinenStatus[machineId]?.queue?.length || 0,
        ...additionalData
    };

    bufferStats.orderHistory.push(entry);
}

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è startNewTasks —Å –±—É—Ñ–µ—Ä–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
function startNewTasks() {
    Object.keys(window.simulation.maschinenStatus).forEach(machineId => {
        const machineStatus = window.simulation.maschinenStatus[machineId];

        if (machineStatus.queue.length === 0) {
            return;
        }

        const canStart = machineStatus.canStartNewTask &&
            machineStatus.frei &&
            !machineStatus.hasUnfinishedTask;

        if (!canStart) {
            return;
        }

        const nextOrder = machineStatus.queue.shift();
        const totalDuration = nextOrder.anzahl * nextOrder.operation.dauer;
        const currentTime = window.simulation.currentTimeMinutes;

        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –±—É—Ñ–µ—Ä–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        updateBufferStatistics(machineId, nextOrder.auftrag_nr, 'start_processing', {
            queueWaitTime: currentTime - (nextOrder.queueEntryTime || currentTime),
            operationDuration: totalDuration
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –º–∞—à–∏–Ω—ã
        machineStatus.frei = false;
        machineStatus.hasUnfinishedTask = true;
        machineStatus.canStartNewTask = false;

        const auftragStatus = window.simulation.auftraegeStatus[nextOrder.auftrag_nr];
        const orderStats = window.simulation.statistics.orderStatistics[nextOrder.auftrag_nr];

        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è
        let waitingTime = 0;
        if (auftragStatus.waitingStartTime) {
            waitingTime = currentTime - auftragStatus.waitingStartTime;
            auftragStatus.totalWaitingTime += waitingTime;
            auftragStatus.waitingStartTime = null;
        }

        auftragStatus.currentOperationStartTime = currentTime;

        if (orderStats.startTime === null) {
            orderStats.startTime = currentTime;
        }

        // –°–æ–∑–¥–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –∑–∞–¥–∞—á—É
        const newTask = {
            auftrag_nr: nextOrder.auftrag_nr,
            maschine: machineId,
            remaining: totalDuration,
            operation: auftragStatus.currentStep + 1,
            paused: false,
            anzahl: nextOrder.anzahl,
            dauerPerUnit: nextOrder.operation.dauer,
            processedUnits: 0,
            totalDuration: totalDuration,
            startTime: currentTime,
            waitingTimeBefore: waitingTime,
            pausedTotalTime: 0
        };

        window.simulation.activeTasks.push(newTask);

        if (!orderStats.machinesUsed.includes(machineId)) {
            orderStats.machinesUsed.push(machineId);
        }
        console.log(`üöÄ AUFGABE GESTARTET: Auftrag ${nextOrder.auftrag_nr} auf Maschine ${machineId}, Dauer: ${totalDuration} Min`);
        addActivity(`Bearbeitung von Auftrag ${nextOrder.auftrag_nr} auf Maschine ${machineId} gestartet`);

    });
}

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è processReadyOrders —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏
function processReadyOrders() {
    const currentDay = getCurrentDay();
    const currentTime = window.simulation.currentTimeMinutes;

    for (const auftrag of window.simulation.auftraegeQueue) {
        const auftragStatus = window.simulation.auftraegeStatus[auftrag.auftrag_nr];

        if (!auftragStatus || auftragStatus.completed) {
            continue;
        }

        let startDay;
        if (typeof auftrag.Start === 'number') {
            startDay = auftrag.Start;
        } else if (typeof auftrag.Start === 'string') {
            startDay = calculateDayFromDate(auftrag.Start);
        } else {
            continue;
        }

        if (startDay > currentDay) {
            continue;
        }

        const hasActiveTask = window.simulation.activeTasks.some(task => task.auftrag_nr === auftrag.auftrag_nr);
        if (hasActiveTask) {
            continue;
        }

        const currentOperation = auftragStatus.arbeitsplaene[auftragStatus.currentStep];
        if (!currentOperation) {
            continue;
        }

        const machineId = currentOperation.maschine;
        const machineStatus = window.simulation.maschinenStatus[machineId];

        if (!machineStatus) {
            console.warn(`‚ö†Ô∏è –ú–∞—à–∏–Ω–∞ ${machineId} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!`);
            continue;
        }

        const alreadyInQueue = machineStatus.queue.some(item => item.auftrag_nr === auftrag.auftrag_nr);
        if (!alreadyInQueue) {
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –º–µ—Ç–∫—É –≤—Ö–æ–¥–∞ –≤ –æ—á–µ—Ä–µ–¥—å
            const queueItem = {
                auftrag_nr: auftrag.auftrag_nr,
                operation: currentOperation,
                anzahl: auftrag.Anzahl || 1,
                queueEntryTime: currentTime // –ù–æ–≤–æ–µ –ø–æ–ª–µ
            };

            machineStatus.queue.push(queueItem);

            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –±—É—Ñ–µ—Ä–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            updateBufferStatistics(machineId, auftrag.auftrag_nr, 'enter_queue', {
                operationNumber: auftragStatus.currentStep + 1,
                queuePosition: machineStatus.queue.length
            });

            console.log(`üìù –ó–∞–∫–∞–∑ ${auftrag.auftrag_nr} –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å –º–∞—à–∏–Ω—ã ${machineId}`);
        }
    }
}

// –ù–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å–æ–±—Ä–∞–Ω–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
function getDetailedOrderAnalysis(auftrag_nr) {
    const orderStats = window.simulation.statistics.orderStatistics[auftrag_nr];
    if (!orderStats) return null;

    return {
        auftrag_nr: auftrag_nr,
        isCompleted: orderStats.endTime !== null,
        totalLeadTime: orderStats.totalLeadTime,
        totalProcessingTime: orderStats.totalProcessingTime,
        totalWaitingTime: orderStats.totalWaitingTime,
        utilizationEfficiency: orderStats.totalProcessingTime / Math.max(1, orderStats.totalLeadTime),
        operationsCount: orderStats.operations.length,
        machinesUsed: orderStats.machinesUsed,
        operations: orderStats.operations.map(op => ({
            operation: op.operationNumber,
            machine: op.machineId,
            duration: op.duration,
            waitingTime: op.waitingTimeBefore,
            efficiency: op.duration / (op.duration + op.waitingTimeBefore)
        }))
    };
}

function getSystemWideStatistics() {
    const completedOrders = Object.keys(window.simulation.statistics.orderStatistics)
        .map(auftrag_nr => getDetailedOrderAnalysis(auftrag_nr))
        .filter(analysis => analysis && analysis.isCompleted);

    const machineStats = Object.keys(window.simulation.statistics.machineUtilization)
        .map(machineId => ({
            machineId: parseInt(machineId),
            ...getMachineEfficiency(machineId),
            bufferHistory: window.simulation.statistics.bufferStatistics[machineId]?.orderHistory || []
        }));

    return {
        summary: {
            totalSimulationTime: window.simulation.statistics.totalSimulationTime,
            completedOrders: completedOrders.length,
            averageLeadTime: completedOrders.length > 0 ?
                completedOrders.reduce((sum, order) => sum + order.totalLeadTime, 0) / completedOrders.length : 0,
            averageWaitingTime: completedOrders.length > 0 ?
                completedOrders.reduce((sum, order) => sum + order.totalWaitingTime, 0) / completedOrders.length : 0,
            systemUtilization: machineStats.length > 0 ?
                machineStats.reduce((sum, m) => sum + m.utilization, 0) / machineStats.length : 0
        },
        orders: completedOrders,
        machines: machineStats
    };
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –≤ JSON
function exportCompleteStatistics() {
    return {
        metadata: {
            exportTime: new Date().toISOString(),
            simulationStartTime: window.simulation.statistics.systemStartTime,
            simulationEndTime: window.simulation.currentTimeMinutes,
            totalDuration: window.simulation.statistics.totalSimulationTime
        },
        systemStats: getSystemWideStatistics(),
        rawData: {
            orderStatistics: window.simulation.statistics.orderStatistics,
            machineUtilization: window.simulation.statistics.machineUtilization,
            bufferStatistics: window.simulation.statistics.bufferStatistics
        }
    };
}

function cleanupCompletedOrders() {
    // –£–¥–∞–ª—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã –∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–π –æ—á–µ—Ä–µ–¥–∏
    const initialQueueLength = window.simulation.auftraegeQueue.length;
    window.simulation.auftraegeQueue = window.simulation.auftraegeQueue.filter(auftrag => {
        const auftragStatus = window.simulation.auftraegeStatus[auftrag.auftrag_nr];
        const isCompleted = auftragStatus && auftragStatus.completed;

        if (isCompleted) {
            console.log(`üóëÔ∏è –£–¥–∞–ª—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π –∑–∞–∫–∞–∑ ${auftrag.auftrag_nr} –∏–∑ –æ—á–µ—Ä–µ–¥–∏`);
        }

        return !isCompleted;
    });

    // –û—á–∏—â–∞–µ–º –æ—á–µ—Ä–µ–¥–∏ –º–∞—à–∏–Ω –æ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤
    Object.keys(window.simulation.maschinenStatus).forEach(machineId => {
        const machineStatus = window.simulation.maschinenStatus[machineId];
        machineStatus.queue = machineStatus.queue.filter(queueItem => {
            const auftragStatus = window.simulation.auftraegeStatus[queueItem.auftrag_nr];
            return auftragStatus && !auftragStatus.completed;
        });
    });
}

// 4. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
function debugSimulationState() {
    console.log("üîç === –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –°–û–°–¢–û–Ø–ù–ò–Ø –°–ò–ú–£–õ–Ø–¶–ò–ò ===");

    const currentDay = getCurrentDay();
    console.log(`üìÖ –¢–µ–∫—É—â–∏–π –¥–µ–Ω—å: ${currentDay}`);
    console.log(`‚ö° –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á: ${window.simulation.activeTasks.length}`);
    console.log(`üì¶ –ó–∞–∫–∞–∑–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏: ${window.simulation.auftraegeQueue.length}`);

    // –ê–Ω–∞–ª–∏–∑ –∑–∞–∫–∞–∑–æ–≤ –ø–æ —Å—Ç–∞—Ç—É—Å—É
    const ordersByStatus = {
        notStarted: 0,
        inProgress: 0,
        completed: 0
    };

    Object.keys(window.simulation.auftraegeStatus).forEach(auftragNr => {
        const status = window.simulation.auftraegeStatus[auftragNr];
        const auftrag = window.simulation.auftraegeQueue.find(a => a.auftrag_nr === auftragNr);

        if (status.completed) {
            ordersByStatus.completed++;
        } else if (auftrag) {
            let startDay;
            if (typeof auftrag.Start === 'number') {
                startDay = auftrag.Start;
            } else if (typeof auftrag.Start === 'string') {
                startDay = calculateDayFromDate(auftrag.Start);
            }

            if (startDay <= currentDay) {
                ordersByStatus.inProgress++;
            } else {
                ordersByStatus.notStarted++;
            }
        }
    });

    console.log(`üìä –°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–æ–≤:`, ordersByStatus);

    // –ê–Ω–∞–ª–∏–∑ –æ—á–µ—Ä–µ–¥–µ–π –º–∞—à–∏–Ω
    let totalQueued = 0;
    Object.keys(window.simulation.maschinenStatus).forEach(machineId => {
        const queueLength = window.simulation.maschinenStatus[machineId].queue.length;
        totalQueued += queueLength;
        if (queueLength > 0) {
            console.log(`üè≠ –ú–∞—à–∏–Ω–∞ ${machineId}: ${queueLength} –∑–∞–∫–∞–∑–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏`);
        }
    });

    console.log(`üìã –í—Å–µ–≥–æ –∑–∞–∫–∞–∑–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—è—Ö –º–∞—à–∏–Ω: ${totalQueued}`);
    console.log("===============================================");
}


function debugDataLoading() {
    console.log("=== –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –î–ê–ù–ù–´–• ===");

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    console.log("üì¶ –ó–∞–∫–∞–∑—ã (auftraege):", window.simulation.auftraege);
    console.log("üìã –†–∞–±–æ—á–∏–µ –ø–ª–∞–Ω—ã (arbeitsplaene):", window.simulation.arbeitsplaene);
    console.log("üè≠ –ú–∞—à–∏–Ω—ã (maschinen):", window.simulation.maschinen);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑—ã
    console.log("üìã –ó–∞–∫–∞–∑—ã –≤ –æ—á–µ—Ä–µ–¥–∏ (auftraegeQueue):", window.simulation.auftraegeQueue);
    console.log("üìä –°—Ç–∞—Ç—É—Å—ã –∑–∞–∫–∞–∑–æ–≤ (auftraegeStatus):", window.simulation.auftraegeStatus);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
    const currentDay = getCurrentDay();
    console.log("üìÖ –¢–µ–∫—É—â–∏–π –¥–µ–Ω—å —Å–∏–º—É–ª—è—Ü–∏–∏:", currentDay);
    console.log("üìÖ –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞:", getCurrentDate().toISOString().split('T')[0]);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –∑–∞–∫–∞–∑ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ
    if (window.simulation.auftraege.length > 0) {
        console.log("üîç –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫–∞–∑–æ–≤:");
        window.simulation.auftraege.forEach(auftrag => {
            const shouldBeActive = auftrag.Start <= currentDay;
            const hasArbeitsplan = window.simulation.arbeitsplaene.some(
                plan => plan.auftrag_nr === auftrag.auftrag_nr
            );

            console.log(`  –ó–∞–∫–∞–∑ ${auftrag.auftrag_nr}:`);
            console.log(`    - –°—Ç–∞—Ä—Ç: ${auftrag.Start}, –¢–µ–∫—É—â–∏–π –¥–µ–Ω—å: ${currentDay}`);
            console.log(`    - –î–æ–ª–∂–µ–Ω –±—ã—Ç—å –∞–∫—Ç–∏–≤–µ–Ω: ${shouldBeActive}`);
            console.log(`    - –ï—Å—Ç—å —Ä–∞–±–æ—á–∏–π –ø–ª–∞–Ω: ${hasArbeitsplan}`);
            console.log(`    - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${auftrag.Anzahl}`);
        });
    }

    console.log("==============================");
}


function debugMachineStatus() {
    console.log("üîç === –û–¢–õ–ê–î–ö–ê –°–û–°–¢–û–Ø–ù–ò–Ø –ú–ê–®–ò–ù ===");
    const currentTime = getCurrentTimeInDay();
    const currentHour = Math.floor(currentTime / 60);
    const currentMinute = currentTime % 60;

    console.log(`‚è∞ –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ —Å–∏–º—É–ª—è—Ü–∏–∏: ${currentHour}:${String(currentMinute).padStart(2, '0')}`);
    const currentDate = getCurrentDate();
    const dayNames = ['–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ', '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞'];
    const dayOfWeek = currentDate.getDay();
    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    console.log(`üìÖ –î–µ–Ω—å –Ω–µ–¥–µ–ª–∏: ${dayNames[dayOfWeek]} ${isWeekend ? '(–í–´–•–û–î–ù–û–ô)' : '(—Ä–∞–±–æ—á–∏–π)'}`)


    Object.keys(window.simulation.maschinenStatus).forEach(machineId => {
        const status = window.simulation.maschinenStatus[machineId];
        const machineData = window.simulation.maschinen.find(m => m.Nr == machineId);

        if (machineData) {
            const isAvailable = isMachineAvailable(machineData);
            const isWorkingTime = isMachineWorkingTime(machineData);
            const workStart = 8;
            const workEnd = 8 + machineData.Kap_Tag;

            console.log(`  –ú–∞—à–∏–Ω–∞ ${machineId}:`);
            console.log(`    - –†–∞–±–æ—á–∏–µ —á–∞—Å—ã: ${workStart}:00 - ${workEnd}:00`);
            console.log(`    - –î–æ—Å—Ç—É–ø–Ω–∞ –ø–æ –¥–∞—Ç–∞–º: ${isAvailable}`);
            console.log(`    - –í —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è: ${isWorkingTime}`);
            console.log(`    - –°–≤–æ–±–æ–¥–Ω–∞: ${status.frei}`);
            console.log(`    - –ú–æ–∂–µ—Ç –Ω–∞—á–∞—Ç—å –∑–∞–¥–∞—á—É: ${status.canStartNewTask}`);
        }
    });
    console.log("=================================");
}

function initMaschinen(maschinen) {
    console.log("üè≠ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—à–∏–Ω...");
    window.simulation.maschinenStatus = {};
    window.simulation.statistics.machineUtilization = {};

    for (const m of maschinen) {
        const isAvailable = isMachineAvailable(m);
        const isWorkingTime = isMachineWorkingTimeAndAvailable(m);

        // –î–ª—è –∫–∞–∂–¥–æ–π –º–∞—à–∏–Ω—ã —Å–æ–∑–¥–∞—Ç—å –±—É—Ñ–µ—Ä–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É

        window.simulation.maschinenStatus[m.Nr] = {
            frei: true, // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –≤—Å–µ –º–∞—à–∏–Ω—ã —Å–≤–æ–±–æ–¥–Ω—ã
            kapTag: m.Kap_Tag,
            bezeichnung: m.Bezeichnung,
            verfuegbar: isAvailable,
            canStartNewTask: isWorkingTime && isAvailable,
            hasUnfinishedTask: false, // –ï—Å—Ç—å –ª–∏ –Ω–µ–∑–∞–∫–æ–Ω—á–µ–Ω–Ω–∞—è –∑–∞–¥–∞—á–∞
            waitingForWorkingTime: false, // –ñ–¥–µ—Ç –ª–∏ –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—á–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ —Å –Ω–µ–∑–∞–∫–æ–Ω—á–µ–Ω–Ω–æ–π –∑–∞–¥–∞—á–µ–π
            queue: [] // –î–æ–±–∞–≤–∏—Ç—å –æ—á–µ—Ä–µ–¥—å –∑–∞–∫–∞–∑–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π –º–∞—à–∏–Ω—ã
        };

        window.simulation.statistics.machineUtilization[m.Nr] = {
            totalTime: 0,
            workingTime: 0,
            availableTime: 0,
            utilization: 0,

            // –ù–û–í–´–ï –ü–û–õ–Ø
            idleTime: 0,
            unavailableTime: 0,
            operationsCompleted: 0,
            totalPartsProcessed: 0,
            utilizationHistory: []
        };

        window.simulation.statistics.bufferStatistics[m.Nr] = {
            orderHistory: [], // –ó–ê–ú–ï–ù–ò–¢–¨ –≤—Å–µ –ø–æ–ª—è –Ω–∞ —ç—Ç–æ
        };
        const currentDate = getCurrentDate().toISOString().split('T')[0];
        const currentTime = `${Math.floor(getCurrentTimeInDay() / 60)}:${String(getCurrentTimeInDay() % 60).padStart(2, '0')}`;

        console.log(`üîß –ú–∞—à–∏–Ω–∞ ${m.Nr} (${m.Bezeichnung}): –¥–æ—Å—Ç—É–ø–Ω–∞=${isAvailable}, —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è=${isWorkingTime}, –¥–∞—Ç–∞=${currentDate}, –≤—Ä–µ–º—è=${currentTime}`);
    }
}

function updateMachineUtilization() {
    Object.keys(window.simulation.maschinenStatus).forEach(machineId => {
        const machine = window.simulation.maschinenStatus[machineId];
        const machineData = window.simulation.maschinen.find(m => m.Nr == machineId);
        const utilization = window.simulation.statistics.machineUtilization[machineId];

        if (utilization && machineData) {
            const isAvailable = isMachineAvailable(machineData);
            const isWorkingTimeAndAvailable = isMachineWorkingTimeAndAvailable(machineData);

            if (isWorkingTimeAndAvailable) {
                utilization.availableTime++;

                if (!machine.frei) {
                    utilization.workingTime++;
                } else {
                    // –ù–û–í–û–ï: –º–∞—à–∏–Ω–∞ –¥–æ—Å—Ç—É–ø–Ω–∞, –≤ —Ä–∞–±–æ—á–µ–µ –≤—Ä–µ–º—è, –Ω–æ –ø—Ä–æ—Å—Ç–∞–∏–≤–∞–µ—Ç
                    utilization.idleTime++;
                }
            } else if (!isAvailable) {
                // –ù–û–í–û–ï: –º–∞—à–∏–Ω–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ –¥–∞—Ç–∞–º
                utilization.unavailableTime++;
            }

            utilization.totalTime++;

            // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç —É—Ç–∏–ª–∏–∑–∞—Ü–∏–∏
            utilization.utilization = utilization.availableTime > 0 ?
                (utilization.workingTime / utilization.availableTime * 100).toFixed(1) : 0;

            // –ù–û–í–û–ï: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ (–∫–∞–∂–¥—ã–µ 60 –º–∏–Ω—É—Ç)
            if (window.simulation.currentTimeMinutes % 60 === 0) {
                utilization.utilizationHistory.push({
                    time: window.simulation.currentTimeMinutes,
                    utilization: parseFloat(utilization.utilization),
                    isWorking: !machine.frei && isWorkingTimeAndAvailable
                });
            }
        }
    });
}


// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥—É–ª—è
async function initialize() {
    await loadInitialData();
    debugDataLoading();
    draw(); // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö
}

// Event listeners –¥–ª—è –∫–Ω–æ–ø–æ–∫ (–µ—Å–ª–∏ –æ–Ω–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç)
if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        const speedSlider = document.getElementById("speedSlider");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const resetBtn = document.getElementById("resetBtn");

        if (speedSlider) {
            speedSlider.addEventListener("change", (e) => {
                const value = parseInt(e.target.value);
                window.simulation.simulationMinutesPerStep = value;

                let timeLabel;
                if (value < 60) {
                    timeLabel = `${value} Min`;
                } else if (value < 1440) {
                    timeLabel = `${Math.floor(value / 60)} Std`;
                } else {
                    timeLabel = `${Math.floor(value / 1440)} Tag`;
                }

                console.log(`‚öôÔ∏è Simulationsgeschwindigkeit: ${timeLabel} pro Sekunde —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏`);
            });

        }

        if (startBtn) startBtn.addEventListener("click", startSimulation);
        if (stopBtn) stopBtn.addEventListener("click", stopSimulation);
        if (resetBtn) resetBtn.addEventListener("click", resetSimulation);
    });
}

// –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ò

function getOrderStatistics(auftrag_nr) {
    return window.simulation.statistics.orderStatistics[auftrag_nr];
}

function getMachineEfficiency(machineId) {
    const stats = window.simulation.statistics.machineUtilization[machineId];
    if (!stats) return null;

    return {
        utilization: parseFloat(stats.utilization),
        operationsCompleted: stats.operationsCompleted,
        totalPartsProcessed: stats.totalPartsProcessed,
        idleTime: stats.idleTime,
        workingTime: stats.workingTime,
        efficiency: stats.totalPartsProcessed / Math.max(1, stats.availableTime)
    };
}

function getAverageLeadTime() {
    const completedOrders = Object.values(window.simulation.statistics.orderStatistics)
        .filter(order => order.endTime !== null);

    if (completedOrders.length === 0) return 0;

    const totalLeadTime = completedOrders.reduce((sum, order) => sum + order.totalLeadTime, 0);
    return totalLeadTime / completedOrders.length;
}

function exportStatistics() {
    return {
        simulation: {
            totalTime: window.simulation.currentTimeMinutes,
            completedOrders: window.simulation.statistics.completedTasks,
            averageLeadTime: getAverageLeadTime()
        },
        orders: window.simulation.statistics.orderStatistics,
        machines: Object.keys(window.simulation.statistics.machineUtilization).map(id => ({
            id: parseInt(id),
            ...getMachineEfficiency(id)
        }))
    };
}

function logDetailedStatistics() {
    console.log("üìä === –î–ï–¢–ê–õ–¨–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê ===");
    console.log("–ó–∞–∫–∞–∑—ã:", window.simulation.statistics.orderStatistics);
    console.log("–ú–∞—à–∏–Ω—ã:", window.simulation.statistics.machineUtilization);
    console.log("–≠–∫—Å–ø–æ—Ä—Ç:", exportStatistics());
    console.log("================================");
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª—è—Ö
export {
    loadInitialData,
    getArbeitsplaeneFor,
    initialize,
    startSimulation,
    stopSimulation,
    resetSimulation,
    addActivity,
    getCurrentTimeInDay,
    isMachineWorkingTime,
    getCurrentDate,
    isMachineAvailable,
    isMachineWorkingTimeAndAvailable,
    checkSimulationCompletion,
    simulationStep,
    debugSimulationState,
    updateMachineStatuses,
    processReadyOrders,
    startNewTasks,
    processActiveTasks,
    cleanupCompletedOrders,
    // –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –°–¢–ê–¢–ò–°–¢–ò–ö–ò
    getOrderStatistics,
    getMachineEfficiency,
    getAverageLeadTime,
    exportStatistics,
    logDetailedStatistics
};

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ (–µ—Å–ª–∏ –Ω–µ –≤ –º–æ–¥—É–ª—å–Ω–æ–π —Å—Ä–µ–¥–µ)
if (typeof window !== 'undefined') {
    initialize().catch(console.error);
    window.isMachineAvailable = isMachineAvailable;
    window.isMachineWorkingTimeAndAvailable = isMachineWorkingTimeAndAvailable;
    window.isMachineWorkingTime = isMachineWorkingTime;
}