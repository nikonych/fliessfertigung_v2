<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            background-color: #f5f5f5;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            position: absolute;
            top: 0;
            left: 0;
        }

        #back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 20px;
            background: linear-gradient(135deg, #6274e7 0%, #8752a3 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            z-index: 10;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        #back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        /* Унифицированные стили для datetime-display и controls */
        #datetime-display, #controls {
            position: fixed;
            background: linear-gradient(135deg, #6274e7 0%, #8752a3 100%);
            color: white;
            padding: 18px 22px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            z-index: 15;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #datetime-display {
            bottom: 20px;
            right: 20px;
            min-width: 220px;
            text-align: center;
        }

        #controls {
            top: 20px;
            right: 20px;
            min-width: 280px;
            padding: 8px 10px;

        }

        /* Стили для datetime-display */
        #datetime-display .date {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            opacity: 0.9;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #datetime-display .time {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: 1.5px;
            margin-bottom: 6px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #datetime-display .day-info {
            font-size: 12px;
            opacity: 0.8;
            font-weight: 500;
        }

        /* Стили для элементов управления */
        #controls button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            margin: 4px 6px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }

        #controls button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        #controls button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        #controls label {
            color: white;
            font-weight: 600;
            font-size: 14px;
            margin-right: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #controls select {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: inherit;
            font-weight: 500;
            backdrop-filter: blur(5px);
            cursor: pointer;
        }

        #controls select option {
            background: #667eea;
            color: white;
        }

        #controls select:focus {
            outline: 2px solid rgba(255, 255, 255, 0.5);
            outline-offset: 2px;
        }

        /* Группировка элементов управления */
        .control-group {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        #auftragContainer table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        #auftragContainer th, #auftragContainer td {
            border-bottom: 1px solid #ddd;
            padding: 6px 8px;
            text-align: left;
        }

        #auftragContainer thead {
            background-color: #f0f0f0;
            font-weight: bold;
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            #controls {
                right: 10px;
                top: 10px;
                min-width: 250px;
                padding: 15px 18px;
            }

            #datetime-display {
                right: 10px;
                bottom: 10px;
                min-width: 200px;
                padding: 15px 18px;
            }

            #back-button {
                left: 10px;
                top: 10px;
                padding: 10px 16px;
            }
        }

        #datetime-display .status {
            font-size: 12px;
            font-weight: 600;
            margin-top: 8px;
            padding: 4px 8px;
            border-radius: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status.running {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        .status.paused {
            background: rgba(255, 152, 0, 0.3);
            color: #FF9800;
        }

        .status.stopped {
            background: rgba(244, 67, 54, 0.3);
            color: #F44336;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 5% auto;
            padding: 0;
            border-radius: 16px;
            max-width: 1300px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            color: white;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .close:hover {
            opacity: 1;
        }

        .modal-body {
            padding: 20px 30px;
        }

        .stat-section {
            margin-bottom: 25px;
        }

        .stat-section h3 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 8px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .stat-item .label {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .stat-item .value {
            font-size: 20px;
            font-weight: 700;
        }

        .stat-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .stat-table th, .stat-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-table th {
            background: rgba(255, 255, 255, 0.2);
            font-weight: 600;
        }

        .stat-table tbody tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }

        .stat-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .chart-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 10px;
            color: white;
        }
    </style>

</head>

<body>
<button id="back-button" onclick="window.location.href='home.html'">← Zurück</button>

<!-- Дата и время -->
<div id="datetime-display">
    <div class="date" id="current-date">Wird geladen...</div>
    <div class="time" id="current-time">--:--</div>
    <div class="day-info" id="day-info">Tag 0</div>
    <div class="status" id="simulation-status">Gestoppt</div>
</div>


<div id="controls">
    <div class="control-group">
        <button id="startBtn">Start</button>
        <button id="stopBtn">Stop</button>
        <button id="resetBtn">Reset</button>
        <label for="speedSlider">Intervall:</label>
        <select id="speedSlider">
            <option value="1">1 Min</option>
            <option value="5">5 Min</option>
            <option value="10">10 Min</option>
            <option value="15">15 Min</option>
            <option value="30">30 Min</option>
            <option value="60">1 Std</option>
            <option value="120">2 Std</option>
            <option value="180">3 Std</option>
            <option value="300">5 Std</option>
            <option value="720">12 Std</option>
            <option value="1440">24 Std</option>
            <option value="2880">48 Std</option>
            <option value="5760">96 Std</option>
            <option value="11520">192 Std</option>
        </select>
        <button id="statistic">Statistic</button>
    </div>
</div>

<canvas id="canvas"></canvas>

<div id="statisticsModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Simulationsstatistik</h2>
            <span class="close">&times;</span>
        </div>
        <div class="modal-body" id="statisticsContent">
            <!-- Содержимое будет генерироваться JavaScript -->
        </div>
    </div>
</div>

<script type="module">
    // Функции для работы с датой и временем
    function updateDateTime() {
        if (!window.simulation) return;

        const simulation = window.simulation;
        const totalMinutes = simulation.currentTimeMinutes || 0;

        // Вычисляем дни, часы и минуты
        const days = Math.floor(totalMinutes / (24 * 60));
        const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
        const minutes = totalMinutes % 60;

        // ИСПРАВЛЕНО: Начальная дата 1 января 2022
        const startDate = new Date('2022-01-01'); // или new Date(2022, 0, 1)
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + days);


        // Форматируем дату
        const dateOptions = {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        };
        const formattedDate = currentDate.toLocaleDateString('de-DE', dateOptions);

        // Форматируем время
        const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;


        // Обновляем элементы
        document.getElementById('current-date').textContent = formattedDate;
        document.getElementById('current-time').textContent = timeString;

        // ТАКЖЕ ИСПРАВИТЬ расчет дня симуляции:
        const simulationDay = Math.floor(totalMinutes / (24 * 60));
        document.getElementById('day-info').textContent = `Simulationstag ${simulationDay}`;

        // Обновляем статус симуляции
        const statusElement = document.getElementById('simulation-status');
        if (simulation.isRunning) {
            statusElement.textContent = 'Aktiviert';
            statusElement.className = 'status running';
        } else if (simulation.isPaused) {
            statusElement.textContent = 'Pause';
            statusElement.className = 'status paused';
        } else {
            statusElement.textContent = 'Gestoppt';
            statusElement.className = 'status stopped';
        }
    }

    // Обновляем каждую секунду
    setInterval(updateDateTime, 1000);

    // Обновляем сразу при загрузке
    document.addEventListener('DOMContentLoaded', () => {
        updateDateTime();
    });

    // Подключаем к глобальному обновлению симуляции
    window.addEventListener('simulationUpdate', updateDateTime);

    // Функция для отображения статистики
    function showStatistics() {
        if (!window.simulation || !window.simulation.statistics) {
            console.error('Simulationsstatistiken sind nicht verfügbar');
            return;
        }

        const modal = document.getElementById('statisticsModal');
        const content = document.getElementById('statisticsContent');
        const stats = window.simulation.statistics;

        content.innerHTML = generateStatisticsHTML(stats);
        modal.style.display = 'block';

        createCharts(stats);
    }

    function createCharts(stats) {
        setTimeout(() => {
            createMachineUtilizationChart(stats.machineUtilization);
            createOrderStatusChart(stats.orderStatistics);
            createProcessingTimeChart(stats.orderStatistics);
            createUtilizationTimeChart(stats.machineUtilization);
        }, 100);
    }

    function createMachineUtilizationChart(machineStats) {
        const ctx = document.getElementById('machineUtilizationChart');
        if (!ctx) return;

        const machines = Object.keys(machineStats);
        const utilizations = machines.map(m => parseFloat(machineStats[m].utilization || 0));

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: machines,
                datasets: [{
                    label: 'Auslastung (%)',
                    data: utilizations,
                    backgroundColor: 'rgba(99, 102, 241, 0.8)',
                    borderColor: 'rgba(99, 102, 241, 1)',
                    borderWidth: 2,
                    borderRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {display: false}
                },
                scales: {
                    y: {beginAtZero: true, max: 100}
                }
            }
        });
    }

    function createProcessingTimeChart(orderStats) {
        const ctx = document.getElementById('processingTimeChart');
        if (!ctx) return;

        const orders = Object.entries(orderStats).filter(([id, order]) => order.totalProcessingTime > 0);
        const orderIds = orders.map(([id]) => id);
        const processingTimes = orders.map(([id, order]) => order.totalProcessingTime || 0);
        const waitingTimes = orders.map(([id, order]) => order.totalWaitingTime || 0);

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: orderIds,
                datasets: [{
                    label: 'Bearbeitungszeit (min)',
                    data: processingTimes,
                    backgroundColor: 'rgba(34, 197, 94, 0.8)',
                    borderColor: 'rgba(34, 197, 94, 1)',
                    borderWidth: 2,
                    borderRadius: 6
                }, {
                    label: 'Wartezeit (min)',
                    data: waitingTimes,
                    backgroundColor: 'rgba(239, 68, 68, 0.8)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 2,
                    borderRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {color: 'white'}
                    }
                },
                scales: {
                    x: {
                        ticks: {color: 'white'},
                        grid: {color: 'rgba(255,255,255,0.1)'}
                    },
                    y: {
                        beginAtZero: true,
                        ticks: {color: 'white'},
                        grid: {color: 'rgba(255,255,255,0.1)'}
                    }
                }
            }
        });
    }

    function createUtilizationTimeChart(machineStats) {
        const ctx = document.getElementById('utilizationTimeChart');
        if (!ctx) return;

        // Получаем данные истории утилизации из первой машины для примера
        const firstMachine = Object.values(machineStats)[0];
        if (!firstMachine || !firstMachine.utilizationHistory) {
            // Если нет данных истории, создаем демо-данные
            const demoData = [];
            const demoLabels = [];
            for (let i = 0; i < 24; i++) {
                demoLabels.push(`${i}:00`);
                demoData.push(Math.random() * 100);
            }

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: demoLabels,
                    datasets: [{
                        label: 'Durchschnittliche Systemauslastung (%)',
                        data: demoData,
                        borderColor: 'rgba(99, 102, 241, 1)',
                        backgroundColor: 'rgba(99, 102, 241, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {color: 'white'}
                        }
                    },
                    scales: {
                        x: {
                            ticks: {color: 'white'},
                            grid: {color: 'rgba(255,255,255,0.1)'}
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {color: 'white'},
                            grid: {color: 'rgba(255,255,255,0.1)'}
                        }
                    }
                }
            });
            return;
        }

        // Создаем график на основе реальных данных
        const datasets = [];
        const colors = ['#6366f1', '#8b5cf6', '#06b6d4', '#10b981', '#f59e0b', '#ef4444'];
        let colorIndex = 0;

        Object.entries(machineStats).forEach(([machineId, stats]) => {
            if (stats.utilizationHistory && stats.utilizationHistory.length > 0) {
                const color = colors[colorIndex % colors.length];
                datasets.push({
                    label: `Maschine ${machineId}`,
                    data: stats.utilizationHistory.map(h => h.utilization),
                    borderColor: color,
                    backgroundColor: color + '20',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3
                });
                colorIndex++;
            }
        });

        const labels = firstMachine.utilizationHistory.map(h => {
            const hours = Math.floor(h.time / 60);
            const minutes = h.time % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        });

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {color: 'white'}
                    }
                },
                scales: {
                    x: {
                        ticks: {color: 'white'},
                        grid: {color: 'rgba(255,255,255,0.1)'}
                    },
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {color: 'white'},
                        grid: {color: 'rgba(255,255,255,0.1)'}
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }

    function createOrderStatusChart(orderStats) {
        const ctx = document.getElementById('orderStatusChart');
        if (!ctx) return;

        const completed = Object.values(orderStats).filter(o => o.endTime).length;
        const active = Object.values(orderStats).filter(o => o.startTime && !o.endTime).length;
        const waiting = Object.values(orderStats).filter(o => !o.startTime).length;

        new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Abgeschlossen', 'In Bearbeitung', 'Wartet'],
                datasets: [{
                    data: [completed, active, waiting],
                    backgroundColor: ['#10b981', '#f59e0b', '#ef4444'],
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {position: 'bottom'}
                }
            }
        });
    }

    function calculateFillPercentage(orderHistory) {
        if (!orderHistory || orderHistory.length === 0) return 0;

        // Сортируем заказы по времени входа
        const sortedOrders = orderHistory.sort((a, b) => a.entryTime - b.entryTime);

        // Получаем временной диапазон
        const startTime = sortedOrders[0].entryTime;
        const endTime = Math.max(...sortedOrders.map(order => order.exitTime || Date.now()));
        const totalTime = endTime - startTime;

        if (totalTime === 0) return 0;

        let filledTime = 0;
        let events = [];

        // Создаем события входа и выхода
        sortedOrders.forEach(order => {
            events.push({time: order.entryTime, type: 'entry'});
            if (order.exitTime) {
                events.push({time: order.exitTime, type: 'exit'});
            }
        });

        // Сортируем события по времени
        events.sort((a, b) => a.time - b.time);

        let currentLevel = 0;
        let lastTime = startTime;

        // Подсчитываем время когда буфер был заполнен
        events.forEach(event => {
            if (currentLevel > 0) {
                filledTime += event.time - lastTime;
            }

            if (event.type === 'entry') {
                currentLevel++;
            } else {
                currentLevel--;
            }

            lastTime = event.time;
        });

        // Добавляем время до конца если буфер все еще заполнен
        if (currentLevel > 0) {
            filledTime += endTime - lastTime;
        }

        return (filledTime / totalTime) * 100;
    }

    function countFillOperations(orderHistory) {
        if (!orderHistory || orderHistory.length === 0) return 0;

        // Количество операций заполнения = количество входящих заказов
        return orderHistory.length;
    }

    function countEmptyOperations(orderHistory) {
        if (!orderHistory || orderHistory.length === 0) return 0;

        // Количество операций опустошения = количество завершенных заказов
        return orderHistory.filter(order => order.exitTime !== null).length;
    }

    function calculateOrderBufferTimes(machineStats) {
        const orderBufferTimes = {};

        // Проходим по всем машинам
        Object.keys(machineStats).forEach(machineId => {
            const machine = machineStats[machineId];

            if (machine.orderHistory) {
                machine.orderHistory.forEach(order => {
                    const orderId = order.auftrag_nr;

                    // Инициализируем объект заказа если его нет
                    if (!orderBufferTimes[orderId]) {
                        orderBufferTimes[orderId] = {
                            totalQuantity: order.quantity,
                            bufferTimes: {},
                            totalBufferTime: 0,
                            machineSequence: []
                        };
                    }

                    // Рассчитываем время в буфере для этой машины
                    const bufferTime = order.exitTime ?
                        (order.exitTime - order.entryTime) :
                        0; // Если заказ еще не завершен

                    orderBufferTimes[orderId].bufferTimes[machineId] = bufferTime;
                    orderBufferTimes[orderId].totalBufferTime += bufferTime;
                    orderBufferTimes[orderId].machineSequence.push({
                        machine: machineId,
                        entryTime: order.entryTime,
                        exitTime: order.exitTime,
                        duration: bufferTime
                    });
                });
            }
        });

        return orderBufferTimes;
    }

    function calculateBufferStatistics(machineStats) {
        const bufferStats = {};

        // Проходим по каждой машине из данных
        Object.keys(machineStats).forEach(machineId => {
            const machine = machineStats[machineId];

            // Рассчитываем статистику буфера для каждой машины
            if (machine.orderHistory) {
                bufferStats[`Buffer_${machineId}`] = {
                    currentLevel: calculateCurrentBuffer(machine.orderHistory),
                    maxLevel: calculateMaxBuffer(machine.orderHistory),
                    averageLevel: calculateAverageBuffer(machine.orderHistory),
                    fillPercentage: calculateFillPercentage(machine.orderHistory),
                    fillCount: countFillOperations(machine.orderHistory),
                    emptyCount: countEmptyOperations(machine.orderHistory),
                    idleTime: calculateBufferIdleTime(machine.orderHistory)
                };
            }
        });

        return bufferStats;
    }

    function calculateCurrentBuffer(orderHistory) {
        // Считаем текущие активные заказы (где exitTime === null)
        return orderHistory.filter(order => order.exitTime === null).length;
    }

    function calculateMaxBuffer(orderHistory) {
        // Находим максимальное количество одновременных заказов
        let maxConcurrent = 0;
        // Логика расчета на основе entryTime/exitTime
        return maxConcurrent;
    }

    function calculateAverageBuffer(orderHistory) {
        // Средний уровень буфера за время симуляции
        const totalOrders = orderHistory.length;
        const activeOrders = orderHistory.filter(order => order.exitTime === null).length;
        return totalOrders > 0 ? activeOrders / totalOrders * 100 : 0;
    }

    // Функция генерации HTML для статистики
    function generateStatisticsHTML(stats) {
        // Получаем данные машин и заказов
        const machineStats = stats.machineUtilization || {};
        const orderStats = stats.orderStatistics || {};
        // ИЗМЕНЕНО: используем новые функции для анализа событий очереди
        const bufferStats = generateBufferStatisticsFromEvents(stats.bufferStatistics || {});
        const orderBufferTimes = calculateOrderBufferTimesFromEvents(stats.bufferStatistics || {});

        // Вычисляем общую статистику
// Вычисляем общую статистику
        const totalMachines = Object.keys(machineStats).length;
        const activeMachines = Object.values(machineStats).filter(m => parseFloat(m.utilization || 0) > 0).length;
        const totalOrders = Object.keys(orderStats).length;
        const activeOrders = Object.values(orderStats).filter(o => o.startTime && !o.endTime).length;
        const completedOrders = Object.values(orderStats).filter(o => o.endTime).length;

// Вычисляем общее время обработки
        const totalProcessingTime = Object.values(machineStats).reduce((sum, m) => sum + (m.workingTime || 0), 0);
        const totalPartsProcessed = Object.values(machineStats).reduce((sum, m) => sum + (m.totalPartsProcessed || 0), 0);
        return `
<div class="stat-section">
    <h3>Daten export</h3>
    <div class="control-group">
        <button id="exportCSV" style="background: rgba(34, 197, 94, 0.8); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-right: 10px;">Export in CSV</button>
        <button id="exportSQLite" style="background: rgba(59, 130, 246, 0.8); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">Export in SQLite</button>
    </div>
</div>
        <div class="stat-section">
    <h3>Gesamtstatistik</h3>
    <div class="stat-grid">
        <div class="stat-item">
            <div class="label">Gesamtanzahl Maschinen</div>
            <div class="value">${totalMachines}</div>
        </div>
        <div class="stat-item">
            <div class="label">Aktive Maschinen</div>
            <div class="value">${activeMachines}</div>
        </div>
        <div class="stat-item">
            <div class="label">Gesamtanzahl Aufträge</div>
            <div class="value">${totalOrders}</div>
        </div>
        <div class="stat-item">
            <div class="label">Aktive Aufträge</div>
            <div class="value">${activeOrders}</div>
        </div>
        <div class="stat-item">
            <div class="label">Abgeschlossene Aufträge</div>
            <div class="value">${completedOrders}</div>
        </div>
        <div class="stat-item">
            <div class="label">Verarbeitete Teile</div>
            <div class="value">${totalPartsProcessed}</div>
        </div>
        <div class="stat-item">
            <div class="label">Durchschnittliche Durchlaufzeit</div>
            <div class="value">${formatTime(completedOrders > 0 ? Object.values(orderStats).filter(o => o.endTime || (o.operations && o.operations.some(op => op.endTime))).reduce((sum, o) => sum + (o.totalLeadTime || 0), 0) / completedOrders : 0)}</div>
        </div>
        <div class="stat-item">
            <div class="label">Gesamte Wartezeit</div>
            <div class="value">${formatTime(Object.values(orderStats).reduce((sum, o) => sum + (o.totalWaitingTime || 0), 0))}</div>
        </div>
        <div class="stat-item">
            <div class="label">Gesamte Bearbeitungszeit</div>
            <div class="value">${formatTime(totalProcessingTime)}</div>
        </div>
        <div class="stat-item">
            <div class="label">Simulationszeit</div>
            <div class="value">${formatTime(stats.totalSimulationTime || 0)}</div>
        </div>
        <div class="stat-item">
            <div class="label">Gesamtanzahl Puffer</div>
            <div class="value">${Object.keys(bufferStats).length}</div>
        </div>
        <div class="stat-item">
            <div class="label">Gefüllte Puffer</div>
            <div class="value">${Object.values(bufferStats).filter(b => (b.currentLevel || 0) > 0).length}</div>
        </div>
    </div>
</div>

<div class="stat-section">
    <h3>Leistungsdiagramme</h3>
    <div class="chart-grid">
        <div class="chart-container">
            <div class="chart-title">Maschinenauslastung</div>
            <canvas style="margin-top: 40px; margin-left: 30px;" id="machineUtilizationChart"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Auftragsstatus</div>
            <canvas style="margin-top: 40px; margin-left: 30px;" id="orderStatusChart"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Bearbeitungszeit pro Auftrag</div>
            <canvas style="margin-top: 40px; margin-left: 30px;" id="processingTimeChart"></canvas>
        </div>
        <!--
        <div class="chart-container">
            <div class="chart-title">Maschinenauslastung über Zeit</div>
            <canvas id="utilizationTimeChart"></canvas>
        </div>
        -->
    </div>
</div>

<div class="stat-section">
    <h3>Maschinenstatistik</h3>
    ${generateMachineStatisticsHTML(machineStats)}
</div>

<div class="stat-section">
    <h3>Auftragsstatistik</h3>
    ${generateOrderStatisticsHTML(orderStats)}
</div>

<div class="stat-section">
    <h3>Pufferstatistik</h3>
    ${generateBufferStatisticsHTML(bufferStats)}
</div>

<div class="stat-section">
    <h3>Verweilzeit der Aufträge in Puffern</h3>
    ${generateOrderBufferTimesHTML(orderBufferTimes)}
</div>

    `;
    }

    function exportToCSV(stats) {
        const csvData = [];

        // Получаем все данные
        const machineStats = stats.machineUtilization || {};
        const orderStats = stats.orderStatistics || {};
        const bufferStats = generateBufferStatisticsFromEvents(stats.bufferStatistics || {});
        const orderBufferTimes = calculateOrderBufferTimesFromEvents(stats.bufferStatistics || {});

        // === ОБЩАЯ СТАТИСТИКА ===
        csvData.push(['=== GESAMTSTATISTIK ===']);
        csvData.push(['Parameter', 'Wert']);


        const totalMachines = Object.keys(machineStats).length;
        const activeMachines = Object.values(machineStats).filter(m => parseFloat(m.utilization || 0) > 0).length;
        const totalOrders = Object.keys(orderStats).length;
        const activeOrders = Object.values(orderStats).filter(o => o.startTime && !o.endTime).length;
        const completedOrders = Object.values(orderStats).filter(o => o.endTime).length;
        const totalProcessingTime = Object.values(machineStats).reduce((sum, m) => sum + (m.workingTime || 0), 0);
        const totalPartsProcessed = Object.values(machineStats).reduce((sum, m) => sum + (m.totalPartsProcessed || 0), 0);
        const totalBuffers = Object.keys(bufferStats).length;
        const filledBuffers = Object.values(bufferStats).filter(b => (b.currentLevel || 0) > 0).length;

        // Расчет среднего времени выполнения
        const avgLeadTime = completedOrders > 0 ?
            Object.values(orderStats)
                .filter(o => o.endTime || (o.operations && o.operations.some(op => op.endTime)))
                .reduce((sum, o) => sum + (o.totalLeadTime || 0), 0) / completedOrders : 0;

        const totalWaitingTime = Object.values(orderStats).reduce((sum, o) => sum + (o.totalWaitingTime || 0), 0);
        csvData.push(['Gesamtanzahl Maschinen', totalMachines]);
        csvData.push(['Aktive Maschinen', activeMachines]);
        csvData.push(['Gesamtanzahl Aufträge', totalOrders]);
        csvData.push(['Aktive Aufträge', activeOrders]);
        csvData.push(['Abgeschlossene Aufträge', completedOrders]);
        csvData.push(['Verarbeitete Teile', totalPartsProcessed]);
        csvData.push(['Durchschnittliche Durchlaufzeit (Minuten)', Math.round(avgLeadTime)]);
        csvData.push(['Gesamte Wartezeit (Minuten)', Math.round(totalWaitingTime)]);
        csvData.push(['Gesamte Bearbeitungszeit (Minuten)', Math.round(totalProcessingTime)]);
        csvData.push(['Simulationszeit (Minuten)', Math.round(stats.totalSimulationTime || 0)]);
        csvData.push(['Gesamtanzahl Puffer', totalBuffers]);
        csvData.push(['Gefüllte Puffer', filledBuffers]);

        csvData.push([]);

        // === СТАТИСТИКА МАШИН ===
        csvData.push(['=== MASCHINENSTATISTIK ===']);
        csvData.push([
            'Maschine', 'Auslastung (%)', 'Betriebszeit (Minuten)', 'Leerlaufzeit (Minuten)',
            'Nichtverfügbarkeitszeit (Minuten)', 'Verfügbare Zeit (Minuten)', 'Abgeschlossene Operationen',
            'Verarbeitete Teile', 'Gesamtzeit (Minuten)'
        ]);


        Object.entries(machineStats).forEach(([machineId, stats]) => {
            csvData.push([
                machineId,
                parseFloat(stats.utilization || 0).toFixed(1),
                stats.workingTime || 0,
                stats.idleTime || 0,
                stats.unavailableTime || 0,
                stats.availableTime || 0,
                stats.operationsCompleted || 0,
                stats.totalPartsProcessed || 0,
                stats.totalTime || 0
            ]);
        });

        csvData.push([]);

        // === СТАТИСТИКА ЗАКАЗОВ ===
        csvData.push(['=== AUFTRAGSSTATISTIK ===']);
        csvData.push([
            'Auftrag', 'Status', 'Anzahl', 'Durchlaufzeit (Minuten)',
            'Bearbeitungszeit (Minuten)', 'Wartezeit (Minuten)', 'Pausenzeit (Minuten)',
            'Operationen', 'Maschinen', 'Startzeit', 'Endzeit'
        ]);


        Object.entries(orderStats).forEach(([orderId, order]) => {
    const totalPausedTime = order.operations ?
        order.operations.reduce((sum, op) => sum + (op.pausedTime || 0), 0) : 0;
    const machines = (order.machinesUsed || []).join('; ') || 'Keine';
    const startTime = order.startTime ? new Date(order.startTime).toLocaleString('de-DE') : 'Nicht gestartet';
    const endTime = order.endTime ? new Date(order.endTime).toLocaleString('de-DE') : 'Nicht abgeschlossen';

    csvData.push([
        orderId,
        getOrderStatusFromOperations(order),
        order.quantity || 0,
        order.totalLeadTime || 0,
        order.totalProcessingTime || 0,
        order.totalWaitingTime || 0,
        Math.round(totalPausedTime),
        order.operations ? order.operations.length : 0,
        machines,
        startTime,
        endTime
    ]);
});

csvData.push([]);

// === ДЕТАЛЬНАЯ СТАТИСТИКА ОПЕРАЦИЙ ===
csvData.push(['=== DETAILLIERTE OPERATIONSSTATISTIK ===']);
csvData.push([
    'Auftrag', 'Operationsnummer', 'Maschine', 'Status', 'Startzeit',
    'Endzeit', 'Bearbeitungszeit (Minuten)', 'Pausenzeit (Minuten)', 'Anzahl'
]);

Object.entries(orderStats).forEach(([orderId, order]) => {
    if (order.operations && order.operations.length > 0) {
        order.operations.forEach((operation, index) => {
            const startTime = operation.startTime ? new Date(operation.startTime).toLocaleString('de-DE') : 'Nicht gestartet';
            const endTime = operation.endTime ? new Date(operation.endTime).toLocaleString('de-DE') : 'Nicht abgeschlossen';
            const status = operation.endTime ? 'Abgeschlossen' :
                (operation.startTime ? 'In Bearbeitung' : 'Wartet');

            csvData.push([
                orderId,
                index + 1,
                operation.machineId || 'Nicht zugewiesen',
                status,
                startTime,
                endTime,
                operation.processingTime || 0,
                operation.pausedTime || 0,
                operation.quantity || 0
            ]);
        });
    }
});

csvData.push([]);

// === СТАТИСТИКА БУФЕРОВ ===
csvData.push(['=== PUFFERSTATISTIK ===']);
csvData.push([
    'Puffer', 'Aktueller Füllstand', 'Maximaler Füllstand', 'Durchschnittlicher Füllstand',
    'Füllzeit (%)', 'Eintritte in Warteschlange', 'Austritte aus Warteschlange',
    'Leerlaufzeit (Minuten)', 'Gesamte Wartezeit (Minuten)', 'Durchschnittliche Wartezeit (Minuten)',
    'Gesamtanzahl Ereignisse', 'Analysezeit (Minuten)'
]);


        Object.entries(bufferStats).forEach(([bufferId, stats]) => {
            csvData.push([
                bufferId,
                stats.currentLevel || 0,
                stats.maxLevel || 0,
                stats.averageLevel || 0,
                (stats.fillPercentage || 0).toFixed(2),
                stats.fillCount || 0,
                stats.emptyCount || 0,
                stats.idleTime || 0,
                Math.round(stats.totalWaitTime || 0),
                Math.round(stats.averageWaitTime || 0),
                stats.totalEvents || 0,
                Math.round(stats.analysisTime || 0)
            ]);
        });

        csvData.push([]);

        // === ВРЕМЯ ЗАКАЗОВ В БУФЕРАХ ===
       csvData.push(['=== VERWEILZEIT DER AUFTRÄGE IN PUFFERN ===']);
csvData.push([
    'Auftrag', 'Anzahl', 'Gesamte Pufferzeit (Minuten)', 'Anzahl Maschinen', 'Details pro Maschine'
]);

    Object.entries(orderBufferTimes).forEach(([orderId, orderData]) => {
        const machineDetails = Object.entries(orderData.waitingDetails || {})
            .map(([machineId, details]) =>
                `${machineId}:${Math.round(details.bufferTime)}min(Pos.${details.queuePosition},Op.${details.operationNumber})`
            )
            .join('; ');

        csvData.push([
            orderId,
            orderData.totalQuantity,
            Math.round(orderData.totalBufferTime),
            Object.keys(orderData.bufferTimes || {}).length,
            machineDetails
        ]);
    });

    csvData.push([]);

    // === ДЕТАЛЬНАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ ОПЕРАЦИЙ ===
    csvData.push(['=== OPERATIONSSABFOLGE NACH AUFTRÄGEN ===']);
    csvData.push([
        'Auftrag', 'Schritt', 'Maschine', 'Zeitpunkt Eintritt in Warteschlange',
        'Bearbeitungsstart', 'Pufferzeit (Minuten)', 'Operationsnummer'
    ]);

    Object.entries(orderBufferTimes).forEach(([orderId, orderData]) => {
        if (orderData.machineSequence && orderData.machineSequence.length > 0) {
            orderData.machineSequence
                .sort((a, b) => a.entryTime - b.entryTime)
                .forEach((seq, index) => {
                    const entryTime = new Date(seq.entryTime).toLocaleString('de-DE');
                    const startTime = seq.startTime ? new Date(seq.startTime).toLocaleString('de-DE') : 'Nicht gestartet';

                    csvData.push([
                        orderId,
                        index + 1,
                        seq.machine,
                        entryTime,
                        startTime,
                        Math.round(seq.duration),
                        seq.operationNumber || 'Nicht angegeben'
                    ]);
                });
        }
    });


        // Создаем CSV строку
        const csvContent = csvData.map(row =>
            row.map(field => `"${field}"`).join(',')
        ).join('\n');

        // Скачиваем файл
        const blob = new Blob(['\ufeff' + csvContent], {type: 'text/csv;charset=utf-8;'});
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `simulation_full_statistics_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function exportToSQLite(stats) {
        try {
            // Инициализируем SQL.js
            const SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
            });

            const db = new SQL.Database();

            // Получаем все данные
            const machineStats = stats.machineUtilization || {};
            const orderStats = stats.orderStatistics || {};
            const bufferStats = generateBufferStatisticsFromEvents(stats.bufferStatistics || {});
            const orderBufferTimes = calculateOrderBufferTimesFromEvents(stats.bufferStatistics || {});

            // === СОЗДАЕМ ТАБЛИЦЫ ===

            // Общая статистика
            db.run(`
                CREATE TABLE general_statistics
                (
                    parameter   TEXT PRIMARY KEY,
                    value       TEXT,
                    description TEXT
                );
            `);

            // Статистика машин
            db.run(`
                CREATE TABLE machine_statistics
                (
                    machine_id               TEXT PRIMARY KEY,
                    utilization_percent      REAL,
                    working_time_minutes     INTEGER,
                    idle_time_minutes        INTEGER,
                    unavailable_time_minutes INTEGER,
                    available_time_minutes   INTEGER,
                    operations_completed     INTEGER,
                    parts_processed          INTEGER,
                    total_time_minutes       INTEGER
                );
            `);

            // Статистика заказов
            db.run(`
                CREATE TABLE order_statistics
                (
                    order_id                      TEXT PRIMARY KEY,
                    status                        TEXT,
                    quantity                      INTEGER,
                    total_lead_time_minutes       INTEGER,
                    total_processing_time_minutes INTEGER,
                    total_waiting_time_minutes    INTEGER,
                    total_paused_time_minutes     INTEGER,
                    operations_count              INTEGER,
                    machines_used                 TEXT,
                    start_time                    TEXT,
                    end_time                      TEXT
                );
            `);

            // Детальная статистика операций
            db.run(`
                CREATE TABLE operation_details
                (
                    id                      INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id                TEXT,
                    operation_number        INTEGER,
                    machine_id              TEXT,
                    status                  TEXT,
                    start_time              TEXT,
                    end_time                TEXT,
                    processing_time_minutes INTEGER,
                    paused_time_minutes     INTEGER,
                    quantity                INTEGER,
                    FOREIGN KEY (order_id) REFERENCES order_statistics (order_id)
                );
            `);

            // Статистика буферов
            db.run(`
                CREATE TABLE buffer_statistics
                (
                    buffer_id                 TEXT PRIMARY KEY,
                    current_level             INTEGER,
                    max_level                 INTEGER,
                    average_level             REAL,
                    fill_percentage           REAL,
                    fill_count                INTEGER,
                    empty_count               INTEGER,
                    idle_time_minutes         INTEGER,
                    total_wait_time_minutes   INTEGER,
                    average_wait_time_minutes REAL,
                    total_events              INTEGER,
                    analysis_time_minutes     INTEGER
                );
            `);

            // Время заказов в буферах
            db.run(`
                CREATE TABLE order_buffer_times
                (
                    order_id            TEXT,
                    machine_id          TEXT,
                    total_quantity      INTEGER,
                    buffer_time_minutes INTEGER,
                    enter_time          TEXT,
                    start_time          TEXT,
                    queue_position      INTEGER,
                    operation_number    INTEGER,
                    PRIMARY KEY (order_id, machine_id)
                );
            `);

            // Последовательность операций
            db.run(`
                CREATE TABLE operation_sequence
                (
                    id               INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id         TEXT,
                    sequence_step    INTEGER,
                    machine_id       TEXT,
                    entry_time       TEXT,
                    start_time       TEXT,
                    duration_minutes INTEGER,
                    operation_number INTEGER
                );
            `);

            // === ЗАПОЛНЯЕМ ДАННЫЕ ===

            // Общая статистика
            const totalMachines = Object.keys(machineStats).length;
            const activeMachines = Object.values(machineStats).filter(m => parseFloat(m.utilization || 0) > 0).length;
            const totalOrders = Object.keys(orderStats).length;
            const activeOrders = Object.values(orderStats).filter(o => o.startTime && !o.endTime).length;
            const completedOrders = Object.values(orderStats).filter(o => o.endTime).length;
            const totalProcessingTime = Object.values(machineStats).reduce((sum, m) => sum + (m.workingTime || 0), 0);
            const totalPartsProcessed = Object.values(machineStats).reduce((sum, m) => sum + (m.totalPartsProcessed || 0), 0);
            const totalBuffers = Object.keys(bufferStats).length;
            const filledBuffers = Object.values(bufferStats).filter(b => (b.currentLevel || 0) > 0).length;

            const avgLeadTime = completedOrders > 0 ?
                Object.values(orderStats)
                    .filter(o => o.endTime || (o.operations && o.operations.some(op => op.endTime)))
                    .reduce((sum, o) => sum + (o.totalLeadTime || 0), 0) / completedOrders : 0;

            const totalWaitingTime = Object.values(orderStats).reduce((sum, o) => sum + (o.totalWaitingTime || 0), 0);

         const generalStmt = db.prepare("INSERT INTO general_statistics VALUES (?, ?, ?)");
        generalStmt.run(['total_machines', totalMachines.toString(), 'Gesamtanzahl Maschinen im System']);
        generalStmt.run(['active_machines', activeMachines.toString(), 'Maschinen mit Auslastung > 0%']);
        generalStmt.run(['total_orders', totalOrders.toString(), 'Gesamtanzahl Aufträge']);
        generalStmt.run(['active_orders', activeOrders.toString(), 'Aufträge in Bearbeitung']);
        generalStmt.run(['completed_orders', completedOrders.toString(), 'Abgeschlossene Aufträge']);
        generalStmt.run(['total_parts_processed', totalPartsProcessed.toString(), 'Gesamtanzahl verarbeiteter Teile']);
        generalStmt.run(['average_lead_time', Math.round(avgLeadTime).toString(), 'Durchschnittliche Durchlaufzeit eines Auftrags (Minuten)']);
        generalStmt.run(['total_waiting_time', Math.round(totalWaitingTime).toString(), 'Gesamte Wartezeit (Minuten)']);
        generalStmt.run(['total_processing_time', Math.round(totalProcessingTime).toString(), 'Gesamte Bearbeitungszeit (Minuten)']);
        generalStmt.run(['simulation_time', Math.round(stats.totalSimulationTime || 0).toString(), 'Simulationsdauer (Minuten)']);
        generalStmt.run(['total_buffers', totalBuffers.toString(), 'Anzahl der Puffer']);
        generalStmt.run(['filled_buffers', filledBuffers.toString(), 'Gefüllte Puffer']);
        generalStmt.free();


            // Статистика машин
            const machineStmt = db.prepare("INSERT INTO machine_statistics VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)");
            Object.entries(machineStats).forEach(([machineId, stats]) => {
                machineStmt.run([
                    machineId,
                    parseFloat(stats.utilization || 0),
                    stats.workingTime || 0,
                    stats.idleTime || 0,
                    stats.unavailableTime || 0,
                    stats.availableTime || 0,
                    stats.operationsCompleted || 0,
                    stats.totalPartsProcessed || 0,
                    stats.totalTime || 0
                ]);
            });
            machineStmt.free();

            // Статистика заказов
            const orderStmt = db.prepare("INSERT INTO order_statistics VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
            Object.entries(orderStats).forEach(([orderId, order]) => {
                const totalPausedTime = order.operations ?
                    order.operations.reduce((sum, op) => sum + (op.pausedTime || 0), 0) : 0;
                const machines = (order.machinesUsed || []).join(', ') || null;
                const startTime = order.startTime ? new Date(order.startTime).toISOString() : null;
                const endTime = order.endTime ? new Date(order.endTime).toISOString() : null;

                orderStmt.run([
                    orderId,
                    getOrderStatusFromOperations(order),
                    order.quantity || 0,
                    order.totalLeadTime || 0,
                    order.totalProcessingTime || 0,
                    order.totalWaitingTime || 0,
                    Math.round(totalPausedTime),
                    order.operations ? order.operations.length : 0,
                    machines,
                    startTime,
                    endTime
                ]);
            });
            orderStmt.free();

            // Детальная статистика операций
            const operationStmt = db.prepare("INSERT INTO operation_details VALUES (NULL, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
            Object.entries(orderStats).forEach(([orderId, order]) => {
                if (order.operations && order.operations.length > 0) {
                    order.operations.forEach((operation, index) => {
                        const startTime = operation.startTime ? new Date(operation.startTime).toISOString() : null;
                        const endTime = operation.endTime ? new Date(operation.endTime).toISOString() : null;
                     const status = operation.endTime ? 'Abgeschlossen' :
                    (operation.startTime ? 'In Bearbeitung' : 'Wartet');


                        operationStmt.run([
                            orderId,
                            index + 1,
                            operation.machineId || null,
                            status,
                            startTime,
                            endTime,
                            operation.processingTime || 0,
                            operation.pausedTime || 0,
                            operation.quantity || 0
                        ]);
                    });
                }
            });
            operationStmt.free();

            // Статистика буферов
            const bufferStmt = db.prepare("INSERT INTO buffer_statistics VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
            Object.entries(bufferStats).forEach(([bufferId, stats]) => {
                bufferStmt.run([
                    bufferId,
                    stats.currentLevel || 0,
                    stats.maxLevel || 0,
                    stats.averageLevel || 0,
                    stats.fillPercentage || 0,
                    stats.fillCount || 0,
                    stats.emptyCount || 0,
                    stats.idleTime || 0,
                    Math.round(stats.totalWaitTime || 0),
                    Math.round(stats.averageWaitTime || 0),
                    stats.totalEvents || 0,
                    Math.round(stats.analysisTime || 0)
                ]);
            });
            bufferStmt.free();

            // Время заказов в буферах
            const orderBufferStmt = db.prepare("INSERT INTO order_buffer_times VALUES (?, ?, ?, ?, ?, ?, ?, ?)");
            Object.entries(orderBufferTimes).forEach(([orderId, orderData]) => {
                Object.entries(orderData.waitingDetails || {}).forEach(([machineId, details]) => {
                    const enterTime = new Date(details.enterTime).toISOString();
                    const startTime = new Date(details.startTime).toISOString();

                    orderBufferStmt.run([
                        orderId,
                        machineId,
                        orderData.totalQuantity,
                        Math.round(details.bufferTime),
                        enterTime,
                        startTime,
                        details.queuePosition,
                        details.operationNumber
                    ]);
                });
            });
            orderBufferStmt.free();

            // Последовательность операций
            const sequenceStmt = db.prepare("INSERT INTO operation_sequence VALUES (NULL, ?, ?, ?, ?, ?, ?, ?)");
            Object.entries(orderBufferTimes).forEach(([orderId, orderData]) => {
                if (orderData.machineSequence && orderData.machineSequence.length > 0) {
                    orderData.machineSequence
                        .sort((a, b) => a.entryTime - b.entryTime)
                        .forEach((seq, index) => {
                            const entryTime = new Date(seq.entryTime).toISOString();
                            const startTime = seq.startTime ? new Date(seq.startTime).toISOString() : null;

                            sequenceStmt.run([
                                orderId,
                                index + 1,
                                seq.machine,
                                entryTime,
                                startTime,
                                Math.round(seq.duration),
                                seq.operationNumber || null
                            ]);
                        });
                }
            });
            sequenceStmt.free();

            // Экспортируем базу данных
            const data = db.export();
            const blob = new Blob([data], {type: 'application/x-sqlite3'});
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `simulation_full_statistics_${new Date().toISOString().split('T')[0]}.db`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            db.close();

        } catch (error) {
    console.error('Fehler beim Export nach SQLite:', error);
    alert('Fehler beim Export nach SQLite: ' + error.message);
    }
    }

    // Hilfsfunktion zur Bestimmung des Auftragsstatus
    function getOrderStatusFromOperations(order) {
        if (order.endTime) return 'Abgeschlossen';
        if (order.startTime) return 'In Bearbeitung';
        if (order.operations && order.operations.length > 0) {
            const lastOperation = order.operations[order.operations.length - 1];
            if (lastOperation.endTime) return 'Abgeschlossen';
            if (lastOperation.startTime) return 'In Bearbeitung';
        }
        return 'Wartet';
    }



    // Вспомогательные функции
    function formatTime(minutes) {
        if (!minutes || minutes === 0) return '0 Min';
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        if (hours > 0) {
            return `${hours} Std ${mins} Min`;
        }
        return `${mins} Min`;
    }

    function formatTimeFromSeconds(seconds) {
        if (!seconds || seconds === 0) return '0 Min';
        const minutes = Math.round(seconds / 60);
        return formatTime(minutes);
    }

    function getOrderStatus(order) {
    if (order.endTime) return 'Abgeschlossen';
    if (order.startTime) return 'In Bearbeitung';
    return 'Wartet';
}

function generateMachineStatisticsHTML(machineStats) {
    if (!machineStats || Object.keys(machineStats).length === 0) {
        return '<p>Keine Maschinendaten verfügbar</p>';
    }

    let html = `
    <table class="stat-table">
        <thead>
            <tr>
                <th>Maschine</th>
                <th>Auslastung (%)</th>
                <th>Betriebszeit</th>
                <th>Leerlaufzeit</th>
                <th>Nichtverfügbarkeitszeit</th>
                <th>Verfügbare Zeit</th>
                <th>Abgeschlossene Operationen</th>
                <th>Verarbeitete Teile</th>
                <th>Gesamtzeit</th>
            </tr>
        </thead>
        <tbody>
    `;


        for (const [machineId, stats] of Object.entries(machineStats)) {
            const utilization = parseFloat(stats.utilization || 0).toFixed(1);
            const workingTime = formatTime(stats.workingTime || 0);
            const idleTime = formatTime(stats.idleTime || 0);
            const unavailableTime = formatTime(stats.unavailableTime || 0);
            const availableTime = formatTime(stats.availableTime || 0);
            const operations = stats.operationsCompleted || 0;
            const parts = stats.totalPartsProcessed || 0;
            const totalTime = formatTime(stats.totalTime || 0);

            html += `
            <tr>
                <td>${machineId}</td>
                <td>${utilization}%</td>
                <td>${workingTime}</td>
                <td>${idleTime}</td>
                <td>${unavailableTime}</td>
                <td>${availableTime}</td>
                <td>${operations}</td>
                <td>${parts}</td>
                <td>${totalTime}</td>
            </tr>
        `;
        }

        html += '</tbody></table>';
        return html;
    }

   function generateOrderStatisticsHTML(orderStats) {
    if (!orderStats || Object.keys(orderStats).length === 0) {
        return '<p>Keine Auftragsdaten verfügbar</p>';
    }

    let html = `
        <table class="stat-table">
            <thead>
                <tr>
                    <th>Auftrag</th>
                    <th>Status</th>
                    <th>Anzahl</th>
                    <th>Durchlaufzeit</th>
                    <th>Bearbeitungszeit</th>
                    <th>Wartezeit</th>
                    <th>Pausenzeit</th>
                    <th>Operationen</th>
                    <th>Maschinen</th>
                </tr>
            </thead>
            <tbody>
        `;


        for (const [orderId, order] of Object.entries(orderStats)) {
            const status = getOrderStatusFromOperations(order);
            const quantity = order.quantity || 0;
            const leadTime = formatTime(order.totalLeadTime || 0);
            const processingTime = formatTime(order.totalProcessingTime || 0);
            const waitingTime = formatTime(order.totalWaitingTime || 0);

            // Вычисляем общее время паузы из операций
            const totalPausedTime = order.operations ?
                order.operations.reduce((sum, op) => sum + (op.pausedTime || 0), 0) : 0;
            const pausedTime = formatTime(totalPausedTime);

            const operationsCount = order.operations ? order.operations.length : 0;
            const machines = (order.machinesUsed || []).join(', ') || 'Nein';

            html += `
            <tr>
                <td>${orderId}</td>
                <td>${status}</td>
                <td>${quantity}</td>
                <td>${leadTime}</td>
                <td>${processingTime}</td>
                <td>${waitingTime}</td>
                <td>${pausedTime}</td>
                <td>${operationsCount}</td>
                <td>${machines}</td>
            </tr>
        `;
        }

        html += '</tbody></table>';
        return html;
    }

    // Функции для анализа данных буферов на основе событий очереди

    function analyzeQueueEvents(queueEvents) {
        if (!queueEvents || queueEvents.length === 0) return null;

        // Сортируем события по времени
        const sortedEvents = [...queueEvents].sort((a, b) => a.time - b.time);

        let currentLevel = 0;
        let maxLevel = 0;
        let totalLevelTime = 0;
        let lastTime = sortedEvents[0].time;
        let totalTime = 0;

        // Для расчета среднего уровня
        let levelSum = 0;
        let timeSum = 0;

        // Подсчитываем статистику по событиям
        for (let i = 0; i < sortedEvents.length; i++) {
            const event = sortedEvents[i];
            const timeDiff = event.time - lastTime;

            // Добавляем время с текущим уровнем
            levelSum += currentLevel * timeDiff;
            timeSum += timeDiff;

            // Обновляем уровень в зависимости от действия
            if (event.action === 'enter_queue') {
                currentLevel = event.currentQueueLength;
            } else if (event.action === 'start_processing') {
                currentLevel = event.currentQueueLength;
            }

            // Обновляем максимальный уровень
            maxLevel = Math.max(maxLevel, currentLevel);
            lastTime = event.time;
        }

        // Рассчитываем финальное время
        const finalTime = sortedEvents[sortedEvents.length - 1].time;
        totalTime = finalTime - sortedEvents[0].time;

        return {
            currentLevel,
            maxLevel,
            averageLevel: timeSum > 0 ? levelSum / timeSum : 0,
            totalTime,
            eventCount: sortedEvents.length,
            firstEventTime: sortedEvents[0].time,
            lastEventTime: finalTime
        };
    }

    function calculateBufferFillPercentage(queueEvents) {
        const analysis = analyzeQueueEvents(queueEvents);
        if (!analysis || analysis.totalTime === 0) return 0;

        // Процент времени когда буфер был заполнен (не пустой)
        let filledTime = 0;
        let currentLevel = 0;
        let lastTime = analysis.firstEventTime;

        for (const event of queueEvents.sort((a, b) => a.time - b.time)) {
            const timeDiff = event.time - lastTime;

            if (currentLevel > 0) {
                filledTime += timeDiff;
            }

            if (event.action === 'enter_queue') {
                currentLevel = event.currentQueueLength;
            } else if (event.action === 'start_processing') {
                currentLevel = event.currentQueueLength;
            }

            lastTime = event.time;
        }

        return analysis.totalTime > 0 ? (filledTime / analysis.totalTime) * 100 : 0;
    }

    function calculateBufferIdleTime(queueEvents) {
        const analysis = analyzeQueueEvents(queueEvents);
        if (!analysis) return 0;

        let idleTime = 0;
        let currentLevel = 0;
        let lastTime = analysis.firstEventTime;

        for (const event of queueEvents.sort((a, b) => a.time - b.time)) {
            const timeDiff = event.time - lastTime;

            // Если уровень 0, то буфер простаивает
            if (currentLevel === 0) {
                idleTime += timeDiff;
            }

            if (event.action === 'enter_queue') {
                currentLevel = event.currentQueueLength;
            } else if (event.action === 'start_processing') {
                currentLevel = event.currentQueueLength;
            }

            lastTime = event.time;
        }

        return Math.round(idleTime); // Возвращаем в минутах
    }

    function countQueueOperations(queueEvents) {
        if (!queueEvents) return {enters: 0, exits: 0};

        const enters = queueEvents.filter(e => e.action === 'enter_queue').length;
        const exits = queueEvents.filter(e => e.action === 'start_processing').length;

        return {enters, exits};
    }

    function calculateWaitingTimes(queueEvents) {
        if (!queueEvents) return {totalWaitTime: 0, averageWaitTime: 0};

        const waitTimes = queueEvents
            .filter(e => e.action === 'start_processing' && e.queueWaitTime)
            .map(e => e.queueWaitTime);

        const totalWaitTime = waitTimes.reduce((sum, time) => sum + time, 0);
        const averageWaitTime = waitTimes.length > 0 ? totalWaitTime / waitTimes.length : 0;

        return {totalWaitTime, averageWaitTime};
    }

    function generateBufferStatisticsFromEvents(queueData) {
        if (!queueData || Object.keys(queueData).length === 0) {
            return {};
        }

        const bufferStats = {};
        // Проходим по каждой машине/буферу
        Object.keys(queueData).forEach(machineId => {
            const events = queueData[machineId].orderHistory;
            console.log(events)
            if (!events || events.length === 0) return;

            const analysis = analyzeQueueEvents(events);
            const operations = countQueueOperations(events);
            const waitTimes = calculateWaitingTimes(events);

            bufferStats[`Buffer_${machineId}`] = {
                currentLevel: analysis.currentLevel,
                maxLevel: analysis.maxLevel,
                averageLevel: Math.round(analysis.averageLevel * 100) / 100,
                fillPercentage: Math.round(calculateBufferFillPercentage(events) * 100) / 100,
                fillCount: operations.enters,
                emptyCount: operations.exits,
                idleTime: calculateBufferIdleTime(events),
                totalWaitTime: Math.round(waitTimes.totalWaitTime),
                averageWaitTime: Math.round(waitTimes.averageWaitTime),
                totalEvents: events.length,
                analysisTime: Math.round(analysis.totalTime)
            };
        });

        return bufferStats;
    }

   function generateBufferStatisticsHTML(bufferStats) {
    if (!bufferStats || Object.keys(bufferStats).length === 0) {
        return '<p>Keine Pufferdaten verfügbar</p>';
    }

    let html = `
    <table class="stat-table">
        <thead>
            <tr>
                <th>Puffer</th>
                <th>Aktueller Füllstand</th>
                <th>Maximaler Füllstand</th>
                <th>Durchschnittlicher Füllstand</th>
                <th>Füllzeit (%)</th>
                <th>Eintritte in Warteschlange</th>
                <th>Austritte aus Warteschlange</th>
                <th>Leerlaufzeit</th>
                <th>Gesamte Wartezeit</th>
                <th>Durchschnittliche Wartezeit</th>
                <th>Gesamtanzahl Ereignisse</th>
            </tr>
        </thead>
        <tbody>
    `;


        for (const [bufferId, stats] of Object.entries(bufferStats)) {
            html += `
            <tr>
                <td>${bufferId}</td>
                <td>${stats.currentLevel || 0}</td>
                <td>${stats.maxLevel || 0}</td>
                <td>${stats.averageLevel || 0}</td>
                <td>${stats.fillPercentage || 0}%</td>
                <td>${stats.fillCount || 0}</td>
                <td>${stats.emptyCount || 0}</td>
                <td>${formatTime(stats.idleTime || 0)}</td>
                <td>${formatTime(stats.totalWaitTime || 0)}</td>
                <td>${formatTime(stats.averageWaitTime || 0)}</td>
                <td>${stats.totalEvents || 0}</td>
            </tr>
        `;
        }

        html += '</tbody></table>';
        return html;
    }

    function calculateOrderBufferTimesFromEvents(queueData) {
        const orderBufferTimes = {};

        if (!queueData) return orderBufferTimes;

        // Проходим по всем машинам
        Object.keys(queueData).forEach(machineId => {
            const events = queueData[machineId].orderHistory;
            if (!events || events.length === 0) return;
            console.log(events)

            // Группируем события по заказам
            const orderEvents = {};
            events.forEach(event => {
                const orderId = event.auftrag_nr;
                if (!orderEvents[orderId]) {
                    orderEvents[orderId] = [];
                }
                orderEvents[orderId].push(event);
            });

            // Анализируем каждый заказ
            Object.keys(orderEvents).forEach(orderId => {
                const orderEventList = orderEvents[orderId].sort((a, b) => a.time - b.time);

                if (!orderBufferTimes[orderId]) {
                    orderBufferTimes[orderId] = {
                        totalQuantity: 1, // Можно получить из других данных
                        bufferTimes: {},
                        totalBufferTime: 0,
                        machineSequence: [],
                        waitingDetails: {}
                    };
                }

                // Рассчитываем время в буфере для этого заказа на этой машине
                const enterEvent = orderEventList.find(e => e.action === 'enter_queue');
                const startEvent = orderEventList.find(e => e.action === 'start_processing');

                if (enterEvent && startEvent) {
                    const bufferTime = startEvent.time - enterEvent.time;
                    const waitTime = startEvent.queueWaitTime || 0;

                    orderBufferTimes[orderId].bufferTimes[machineId] = bufferTime;
                    orderBufferTimes[orderId].totalBufferTime += bufferTime;
                    orderBufferTimes[orderId].waitingDetails[machineId] = {
                        enterTime: enterEvent.time,
                        startTime: startEvent.time,
                        waitTime: waitTime,
                        bufferTime: bufferTime,
                        queuePosition: enterEvent.queuePosition,
                        operationNumber: enterEvent.operationNumber
                    };

                    orderBufferTimes[orderId].machineSequence.push({
                        machine: machineId,
                        entryTime: enterEvent.time,
                        startTime: startEvent.time,
                        duration: bufferTime,
                        operationNumber: enterEvent.operationNumber
                    });
                }
            });
        });

        return orderBufferTimes;
    }

    function generateOrderBufferTimesHTML(orderBufferTimes) {
    if (!orderBufferTimes || Object.keys(orderBufferTimes).length === 0) {
        return '<p>Keine Daten zur Verweilzeit der Aufträge in Puffern verfügbar</p>';
    }

    let html = `
    <table class="stat-table">
        <thead>
            <tr>
                <th>Auftrag</th>
                <th>Anzahl</th>
                <th>Gesamte Pufferzeit</th>
                <th>Details pro Maschine</th>
                <th>Operationsabfolge</th>
            </tr>
        </thead>
        <tbody>
    `;


        for (const [orderId, orderData] of Object.entries(orderBufferTimes)) {
            // Создаем детальную информацию по машинам
            const machineDetails = Object.entries(orderData.waitingDetails || {})
                .map(([machineId, details]) =>
                    `${machineId}: ${formatTime(details.bufferTime)} (Pos.${details.queuePosition}, Op.${details.operationNumber})`
                )
                .join('<br>');

            // Создаем последовательность операций
            const sequence = orderData.machineSequence
                .sort((a, b) => a.entryTime - b.entryTime)
                .map((seq, index) => `${index + 1}. ${seq.machine} (${formatTime(seq.duration)})`)
                .join('<br>');

            html += `
            <tr>
                <td>${orderId}</td>
                <td>${orderData.totalQuantity}</td>
                <td>${formatTime(orderData.totalBufferTime)}</td>
                <td>${machineDetails}</td>
                <td>${sequence}</td>
            </tr>
        `;
        }

        html += '</tbody></table>';
        return html;
    }

    // Обработчики для экспорта (добавить после document.getElementById('statistic').addEventListener...)
    document.addEventListener('click', function (event) {
        if (event.target.id === 'exportCSV') {
            if (window.simulation && window.simulation.statistics) {
                exportToCSV(window.simulation.statistics);
            } else {
                alert('Keine Daten zum Exportieren verfügbar');

            }
        }

        if (event.target.id === 'exportSQLite') {
            if (window.simulation && window.simulation.statistics) {
                exportToSQLite(window.simulation.statistics);
            } else {
                alert('Keine Daten zum Exportieren verfügbar');

            }
        }
    });

    // Обработчики событий
    document.getElementById('statistic').addEventListener('click', showStatistics);

    document.querySelector('.close').addEventListener('click', function () {
        document.getElementById('statisticsModal').style.display = 'none';
    });

    window.addEventListener('click', function (event) {
        const modal = document.getElementById('statisticsModal');
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });
</script>

<script type="module" src="../ui/simulation/canvas.js"></script>
<script type="module" src="../core/simulation.js"></script>
</body>
</html>